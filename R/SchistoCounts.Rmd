---
title: "SchistoDE"
author: "Laura Gramolini"
date: '2022-07-15'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(Rsubread)
library(tidyverse)
library(dplyr)
```

I'm setting the directory to where my Bam files are and create a list to give to FeatureCounts, together with the annotation file
```{r}
setwd("/SAN/Lauras_territory/Novaseq/schisto/AllschistoBAM/")
schisto_files <- list.files(".", pattern = "[.]bam")
SchistoFCounts <- featureCounts(files =schisto_files, isPairedEnd=TRUE, isGTFAnnotationFile=TRUE, annot.ext="/SAN/Lauras_territory/schisto_genome/schisto_annotation.gtf",  nthreads = 40)
```

Export counts as a dataframe in another object cause I want to see:
```{r}
SScountdf <- as.data.frame(SchistoFCounts$counts)
```

And save it, cause you never know:
```{r}
write.table(SScountdf, file = "~/data/SScountdf")
```

Now I have the FeatureCounts object containing the count matrix



#############################################Some sanity checks to play##########################################################
Try to build a graph, for now only one sample at the time
```{r}
ggplot(SScountdf) +
  geom_histogram(aes(x = ConditionA03), stat = "bin", bins = 200) +
  xlab("Raw expression counts") +
  ylab("Number of genes")+
  scale_x_log10()

```

Here we can build a graph with several samples for the same condition
```{r}
ggplot(pivot%>%
         filter(grepl("ConditionL", name)))+
  geom_histogram(aes(x = value), stat = "bin", bins = 200) +
  xlab("Raw expression counts") +
  ylab("Number of genes")+
  scale_x_log10()+
  facet_wrap(~name)

```

We might try to check the normalized in the same way and compare ...


################################################Going on with DEseq pipeline####################################################
Load the metadata for Schistocephalus

```{r}
SScolData <- read.table("~/data/schistoData.txt")
```

And Now I can start loading the data in DEseq2 but first let's check:
```{r}
head(SchistoFCounts$counts)
```

```{r}
SScolData
```

These two files need to have the samples named in the same way so we have to remove the .bam from SchistoFCounts
```{r}
colnames(SchistoFCounts$counts) <- sub(".bam", "", colnames(SchistoFCounts$counts))
head(SchistoFCounts$counts)
```

Loading the tables in DEseq2
I would put here the design already: ~ Host so then we run the model directly
Also we put Free as reference level and we have to specify it in the colData loading
```{r}
str(SScolData)
SScolData$Host <- as.factor(SScolData$Host) %>% 
  relevel(ref="Free")
SSDEseq <- DESeqDataSetFromMatrix(
  countData = SchistoFCounts$counts,
  colData = SScolData,
  design= ~ Host)

```

Let's remove the genes that are counted less than 10 times in all the samples
For now ok, but then decide the threshold base on a reason, why 10? why 20? For the sum of the samples? At least how many? Make several try. Always do things that you can justify
```{r}
keep <- rowSums(counts(SSDEseq)) >= 10
SSDEseq <- SSDEseq[keep,]
```

Let's plot sd vS mean of each gene to see if the range of variance is the same at different ranges of mean, so to see if they are homoskedastic:
```{r}
lambda <- 10^seq(from = -1, to = 2, length = 1000) ###here, Poisson counts with a range of lambda from 0.1 to 100
SSmatrix <- matrix(rpois(1000*100, lambda), ncol = 100)
library("vsn")
meanSdPlot(SSmatrix, ranks = TRUE)
```

They are not, and this is normal for RNA-seq data, cause lowly expressed genes will have a low range of variance, and this will reflect on the PCA or other exploratory analysis, so we need to transform the data:
I'm gonna apply the vst transformation cause I have more tha 50 samples and because ...
And I will run it blind so the variance doesn't get overestimated by the sample size
(look into it)
```{r}
SSDEseqvst <- vst(SSDEseq, blind = TRUE)
head(assay(SSDEseqvst), 3)
```

Let's see how it looks now

```{r}
meanSdPlot(assay(SSDEseqvst), rank=TRUE)
```

And plotting 2 random genes:
```{r}
SSvstdf <- as_data_frame(assay(SSDEseqvst)[, 1:2]) %>% mutate(transformation = "vst")
colnames(SSvstdf)[1:2] <- c("x", "y") 
lvls <- c("vst")
SSvstdf$transformation <- factor(SSvstdf$transformation, levels = lvls)
ggplot(SSvstdf, aes(x=x, y=y))+geom_hex(bins=80)+
  coord_fixed()
```
I'm not sure how to interpret this... I'm not too convinced is good enough, but this is only for preliminary visualization

Let's calculate the distance matrix between samples and plot it to have an idea of the grouping:
```{r}
SSDist <- dist(t(assay(SSDEseqvst)))
```

With an heatmap for example:

```{r}
library("pheatmap")
library("RColorBrewer")
SSDistM <- as.matrix( SSDist )
rownames(SSDistM) <- paste(SScolData$Condition)
colnames(SSDistM) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(SSDist,
         clustering_distance_rows = SSDist,
         clustering_distance_cols = SSDist,
         col = colors)
```
We would need an indication of what they are ... like names, but it's easier just look at the PCA:
```{r}
plotPCA(SSDEseqvst, intgroup=("Condition"))
```

Let's check more details on the samples:
```{r}
SSPCAdata <- plotPCA(SSDEseqvst, intgroup=c("Host", "Stage"), returnData=TRUE) ##ReturnData means do not plot but return them
SSpercentVar <- round(100*attr(SSPCAdata, "SSpercentVar")) ####Why is this empty?
ggplot(SSPCAdata, aes(PC1, PC2, color=Stage, shape=Host))+
  geom_point(size=3)+
  xlab(paste0("PC1: ", SSpercentVar[1], "% variance")) +
  ylab(paste0("PC2: ", SSpercentVar[2], "% variance")) +
  coord_fixed()
```

Let's make it nice for the poster:
```{r}
SSPCAdata <- plotPCA(SSDEseqvst, intgroup=c("Host", "Stage"), returnData=TRUE) ##ReturnData means do not plot but return them

SSntop=500
  SSv <- rowVars(assay(SSDEseqvst))
  SSselect <- order(SSv, decreasing = TRUE)[seq_len(min(SSntop,
                                                     length(SSv)))]
 ############## SSpca <- prcomp(t(assay(SSDEseqvst)[SSselect, ])) ###This is not necessary if I use SSPCAdata. Are these equivalent? I think so
  
  SSpercentVar <- SSPCAdata$sdev^2/sum(SSPCAdata$sdev^2)
  SSpercentVar <- round(SSpercentVar[1:2]*100,0)

  
SSpcaplot <- ggplot(SSPCAdata, aes(PC1, PC2, color=Stage, shape=Host))+
  geom_point(size=5)+
  xlab(paste0("PC1: ", SSpercentVar[1], "% variance")) +
  ylab(paste0("PC2: ", SSpercentVar[2], "% variance")) +
  scale_shape_manual(values = c("Copepod" = 15, 
                                "Free" = 17, 
                                "Stickleback" = 16,
                                "Bird" = 4)) +
  scale_color_manual(values = c("Growing" = "gray0",
                                "Infecting"= "firebrick",
                                "Reproducing"= "goldenrod3",
                                "Transmission" = "darkgreen",
                                "Growing-Transmission" = "cyan4")) +
  coord_fixed()+
  theme_bw()+
  theme(text = element_text(size = 15))+
  theme(panel.grid = element_blank(), panel.border = element_blank(), axis.line=element_line(), panel.background = element_rect(fill="transparent"), plot.background = element_rect(fill = "transparent"), legend.background = element_rect("transparent"), legend.key = element_rect(fill="transparent"))

############To save the pics:
#tiff(filename = "SSpca.tiff", width = 5, height = 4, units = "in", res = 1200, compression ="lzw")+
#png(filename = "SSpca.png", width = 5, height = 4, units = "in", res = 1200)  

#Or
#ggsave(SSpcaplot, 
#       filename = "SSpca.png",
#       bg = "transparent")
#But this doesn't allow to customize the resolution  
```


Multi-dimensional-scaling MDS:
```{r}
SSmds <-as.data.frame(colData(SSDEseqvst))  %>%
         cbind(cmdscale(SSDistM))
ggplot(SSmds, aes(x = `1`, y = `2`, color = Stage, shape = Host, size=Pop)) +
  geom_point() + coord_fixed() + ggtitle("MDS with vst data")

```

To visualize some hetmap as additional explorative analysis:
```{r}
library("genefilter")
SStopvargenes <- head(order(rowVars(assay(SSDEseqvst)), decreasing = TRUE), 10) ##Select the 10 genes that bring more variance
SSmat <- assay(SSDEseqvst)[SStopvargenes, ]
SSmat <- SSmat - rowMeans(SSmat)
SS20genes <- as.data.frame(colData(SSDEseqvst)[,c("Stage", "Host")]) ##I can play with this filtering out the other pop and the samples from Hebert to see how it changes
pheatmap(SSmat, annotation_col = SS20genes)
```

The design is already in the object (~ Host) and with the Free living stage as ref level/intercept
Let's try to fit this model
```{r}
SSDEhost <- DESeq(SSDEseq)
SSDEhost
```

And then in the results I can pull out the comparisons I want. It should recalculate each time the different column. Check on that and study the DE command!!!
```{r}
SSres <- results(SSDEhost)
SSres
```
By the default it shows a random comparifon

Let's see the names of the models (?)
```{r}
resultsNames(SSDEhost)
```
They are all against the free stage that I put with as reference, but by changing the results specification I can make the other comparisons:
```{r}
<- results()
summary(AB)

BC <- results(DEtry, c("Condition", "ConditionB", "ConditionC")) ###c() is the contrast
summary(BC)

EL <- results(DEtry, c("Condition", "ConditionE", "ConditionL"))
summary(EL)
```


```{r}
?results
```





We can adjust and change the padj and the lfcthreshold to get only relevant results
Also we need to be careful with the p-value in this case cause we get many false positive, many tests (many genes) reduce robustness of p-values

```{r}
sum(SSres$pvalue<0.05, na.rm=TRUE)
sum(!is.na(SSres$pvalue))
```


```{r}
plotMA(SSres)
```
If we adjust the p-value that's gonna change the color. Adjusted p-value for selecting relevant genes!


What's the value given from the model?










