---
title: "SchistoDE"
author: "Laura Gramolini"
date: '2022-07-15'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

I'M PLAYING WITH GITHUB CAUSE I DON'T KNOW HOW TO USE IT

```{r}
library(Rsubread)
library(tidyverse)
library(dplyr)
```

```{r}
setwd("/SAN/Lauras_territory/Novaseq/schisto/AllschistoBAM/")
schisto_files <- list.files(".", pattern = "[.]bam")
SchistoFCounts <- featureCounts(files =schisto_files, isPairedEnd=TRUE, isGTFAnnotationFile=TRUE, annot.ext="/SAN/Lauras_territory/schisto_genome/schisto_annotation.gtf",  nthreads = 40)
```
Export counts as a dataframe:
```{r}
SScountdf <- as.data.frame(SchistoFCounts$counts)
```
And save it:
```{r}
write.table(SScountdf, file = "~/data/SScountdf")
```

##############################Some sanity checks, to improve, weird to work with count matrix?????#############################
Try to build a graph, for now only one sample at the time, some basic skills missing ...
```{r}
ggplot(SScountdf) +
  geom_histogram(aes(x = ConditionA03.bam), stat = "bin", bins = 200) +
  xlab("Raw expression counts") +
  ylab("Number of genes")+
  scale_x_log10()

```

```{r}
ggplot(pivot%>%
         filter(grepl("ConditionA", name)))+
  geom_histogram(aes(x = value), stat = "bin", bins = 200) +
  xlab("Raw expression counts") +
  ylab("Number of genes")+
  scale_x_log10()+
  facet_wrap(~name)
#scales=freey

```
How to set a threshold for removing?
Check the normalized in the same way











Check the count of reads for each samples to relate with the raw reads
```{r}
SScountsums <- as.data.frame(colSums(SScountdf))
SScountsums
```

Here we can add columns with the raw count of reads to see how much was mapped and assigned












################################################Going on with pipeline#############################################
Load the metadata for schisto

```{r}
SScolData <- read.table("~/data/schistoData.txt")
```

And Now I can start loading the data in DEseq2 but first let's check:
```{r}
head(SchistoFCounts$counts)
```

```{r}
SScolData
```
These two files need to have the same name so we have to remove the .bam from SchistoFCounts
```{r}
colnames(SchistoFCounts$counts) <- sub(".bam", "", colnames(SchistoFCounts$counts))
head(SchistoFCounts$counts)
```

Loading the tables in DEseq2
Should I put here the design already? Should we run it with Stage + Host or Condition and then look how it is made of? Should we also add Stage:Host? And the other variables? Like pop, dual-seq, double infection?


```{r}
SSDEseq <- DESeqDataSetFromMatrix(countData = SchistoFCounts$counts, colData = SScolData, design = ~ Condition) 
SSDEseq
```
Let's keep only the genes counted at least 10 times at least in one sample.
For now ok, but then decide the threshold base on a reason, why 10? why 20? For the sum of the samples? At least how many? Make several try
```{r}
keep <- rowSums(counts(SSDEseq)) >= 10
SSDEseq <- SSDEseq[keep,]
```

Let's plot sd vS mean of each gene to see if the range of variance is the same at different ranges of mean, so to see if they are homoskedastic:
```{r}
lambda <- 10^seq(from = -1, to = 2, length = 1000) ###here, Poisson counts with a range of lambda from 0.1 to 100
SSmatrix <- matrix(rpois(1000*100, lambda), ncol = 100)
library("vsn")
meanSdPlot(SSmatrix, ranks = TRUE)
```

They are not, and this is normal for RNA-seq data, cause lowly expressed genes will have a low range of variance, and this will reflect on the PCA or other explorative analyis, so we need to transform the data:

```{r}
SSDEseqvst <- vst(SSDEseq, blind = TRUE)
head(assay(SSDEseqvst), 3)
```

Let's see how it looks now

```{r}
meanSdPlot(assay(SSDEseqvst), rank=TRUE)
```
SScountsums <- as.data.frame(colSums(SScountdf))
SScountsums
And plotting 2 genes
```{r}
SSvstdf <- as_data_frame(assay(SSDEseqvst)[, 1:2]) %>% mutate(transformation = "vst")
colnames(SSvstdf)[1:2] <- c("x", "y") 
lvls <- c("vst")
SSvstdf$transformation <- factor(SSvstdf$transformation, levels = lvls)
ggplot(SSvstdf, aes(x=x, y=y))+geom_hex(bins=80)+
  coord_fixed()
```
I'm not sure how to interprete this...


Now let'S try the other one (rlog)

```{r}
SSDEseqrld <- rlog(SSDEseq, blind = TRUE)
meanSdPlot(assay(SSDEseqrld), rank=TRUE)
```


```{r}
SSrlddf <- as_data_frame(assay(SSDEseqrld)[, 1:2]) %>% mutate(transformation = "vst")
colnames(SSrlddf)[1:2] <- c("x", "y") 
lvls <- c("vst")
SSrlddf$transformation <- factor(SSrlddf$transformation, levels = lvls)
ggplot(SSrlddf, aes(x=x, y=y))+geom_hex(bins=80)+
  coord_fixed()
```


Not sure which transformation to take, for now I chose the vst and go on with other visualizations

Let's calculate the distance matrix:
```{r}
SSDist <- dist(t(assay(SSDEseqvst)))
SSDist
```

Then we use it to build a heatmap between samples:

```{r}
library("pheatmap")
library("RColorBrewer")
SSDistM <- as.matrix( SSDist )
rownames(SSDistM) <- paste(SScolData$Condition)
colnames(SSDistM) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(SSDist,
         clustering_distance_rows = SSDist,
         clustering_distance_cols = SSDist,
         col = colors)
```
We would need an indication of what they are ...


And the PCA:

```{r}
plotPCA(SSDEseqvst, intgroup=("Condition"))
```


Let's check more:

```{r}
SSPCAdata <- plotPCA(SSDEseqvst, intgroup=c("Host", "Stage"), returnData=TRUE) ##ReturnData means do not plot but return them
SSpercentVar <- round(100*attr(SSPCAdata, "SSpercentVar")) ####Why is this empty?
ggplot(SSPCAdata, aes(PC1, PC2, color=Stage, shape=Host))+
  geom_point(size=3)+
  xlab(paste0("PC1: ", SSpercentVar[1], "% variance")) +
  ylab(paste0("PC2: ", SSpercentVar[2], "% variance")) +
  coord_fixed()
```

Nice PCA plot for poster:
```{r}
SSPCAdata <- plotPCA(SSDEseqvst, intgroup=c("Host", "Stage"), returnData=TRUE) ##ReturnData means do not plot but return them
SSpercentVar <- round(100*attr(SSPCAdata, "SSpercentVar")) ####THIS has been replaced by the rows below before he plot

SSntop=500
  SSv <- rowVars(assay(SSDEseqvst))
  SSselect <- order(SSv, decreasing = TRUE)[seq_len(min(ntop,
                                                     length(v)))]
  SSpca <- prcomp(t(assay(SSDEseqvst)[SSselect, ]))
  SSpercentVar <- SSpca$sdev^2/sum(SSpca$sdev^2)
  SSpercentVar <- round(SSpercentVar[1:2]*100,0)

  
SSpcaplot <- ggplot(SSPCAdata, aes(PC1, PC2, color=Stage, shape=Host))+
  geom_point(size=5)+
  xlab(paste0("PC1: ", SSpercentVar[1], "% variance")) +
  ylab(paste0("PC2: ", SSpercentVar[2], "% variance")) +
  scale_shape_manual(values = c("Copepod" = 15, 
                                "Free" = 17, 
                                "Stickleback" = 16,
                                "Bird" = 4)) +
  scale_color_manual(values = c("Growing" = "gray0",
                                "Infecting"= "firebrick",
                                "Reproducing"= "goldenrod3",
                                "Transmission" = "darkgreen",
                                "Growing-Transmission" = "cyan4")) +
  coord_fixed()+
  theme_bw()+
  theme(text = element_text(size = 15))+
  theme(panel.grid = element_blank(), panel.border = element_blank(), axis.line=element_line(), panel.background = element_rect(fill="transparent"), plot.background = element_rect(fill = "transparent"), legend.background = element_rect("transparent"), legend.key = element_rect(fill="transparent"))
#tiff(filename = "SSpca.tiff", width = 5, height = 4, units = "in", res = 1200, compression ="lzw")+
#png(filename = "SSpca.png", width = 5, height = 4, units = "in", res = 1200)  

#Or
#ggsave(SSpcaplot, 
#       filename = "SSpca.png",
#       bg = "transparent")
#But this doesn't allow to customize the resolution  
```


Multi-dimensional-scaling MDS:
```{r}
SSmds <-as.data.frame(colData(SSDEseqvst))  %>%
         cbind(cmdscale(SSDistM))
ggplot(SSmds, aes(x = `1`, y = `2`, color = Stage, shape = Host, size=Pop)) +
  geom_point() + coord_fixed() + ggtitle("MDS with vst data")

```

Today I want to play, tomorrow I study...

```{r}
library("genefilter")
SStopvargenes <- head(order(rowVars(assay(SSDEseqvst)), decreasing = TRUE), 10) ##Select the 10 genes that bring more variance
SSmat <- assay(SSDEseqvst)[SStopvargenes, ]
SSmat <- SSmat - rowMeans(SSmat)
SS20genes <- as.data.frame(colData(SSDEseqvst)[,c("Stage", "Host")]) ##I can play with this filtering out the other pop and the samples from Hebert to see how it changes
pheatmap(SSmat, annotation_col = SS20genes)
```
Ok, but what happens with the rld?

```{r}
SStopvargenesrld <- head(order(rowVars(assay(SSDEseqrld)), decreasing = TRUE), 20) ##Select the 20 genes that bring more variance
SSmatrld <- assay(SSDEseqrld)[SStopvargenesrld, ]
SSmatrld <- SSmatrld - rowMeans(SSmatrld)
SS20genesrld <- as.data.frame(colData(SSDEseqrld)[,c("Host", "Stage")])
pheatmap(SSmatrld, annotation_col = SS20genes)

```












The design is already in the object (~Condition)
We will try also: Stage + Host, Stage + Host + Stage:host(condition?)
```{r}
SSDEAnalysis <- DESeq(SSDEseq)
SSDEAnalysis
```
```{r}
SSres <- results(SSDEAnalysis)
SSres
??DEseq2
```


```{r}
str(SScolData)
SScolData$Condition <- relevel(as.factor(SScolData$Condition))
DEseqtry <- DESeqDataSetFromMatrix(
  countData = SchistoFCounts$counts,
  colData = SScolData,
  design= ~ Condition)
DEtry <- DESeq(DEseqtry)
results(DEtry)
```

```{r}
resultsNames(DEtry)
```
```{r}
AB <- results(DEtry, name="Condition_ConditionB_vs_ConditionA")
summary(AB)
```

```{r}
BC <- results(DEtry, c("Condition", "ConditionB", "ConditionC")) ###c() is the contrast
summary(BC)
```


```{r}
EL <- results(DEtry, c("Condition", "ConditionE", "ConditionL"))
summary(EL)
```
```{r}
?results
```






We can adjust and change the padj and the lfcthreshold to get only relevant results
Also we need to be careful with the p-value in this case cause we get many false positive, many tests (many genes) reduce robustness of p-values

```{r}
sum(SSres$pvalue<0.05, na.rm=TRUE)
sum(!is.na(SSres$pvalue))
```


```{r}
plotMA(SSres)
```
If we adjust the p-value that's gonna change the color. Adjusted p-value for selecting relevant genes!




But this comparison we did so far it's only between the first and the last condition. Do it multiple and then test the different models










