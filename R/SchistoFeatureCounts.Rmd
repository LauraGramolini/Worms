---
title: "SchistoDE"
author: "Laura Gramolini"
date: '2022-07-15'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(Rsubread)
library(tidyverse)
library(dplyr)
```

I'm setting the directory to where my .Bam files are and create a list to give to FeatureCounts, together with the annotation file
```{r}
setwd("/SAN/Lauras_territory/Novaseq/schisto/AllschistoBAM/")
schisto_files <- list.files(".", pattern = "[.]bam")
SchistoFCounts <- featureCounts(files =schisto_files, isPairedEnd=TRUE, isGTFAnnotationFile=TRUE, annot.ext="/SAN/Lauras_territory/schisto_genome/schisto_annotation.gtf",  nthreads = 40)
```

Export counts as a dataframe in another object cause I want to see:
```{r}
SScountdf <- as.data.frame(SchistoFCounts$counts)
```

And save it, cause you never know:
```{r}
write.table(SScountdf, file = "~/data/SScountdf")
```

Now I have the FeatureCounts object containing the count matrix



#############################################Some sanity checks to play##########################################################
Try to build a graph, for now only one sample at the time
```{r}
ggplot(SScountdf) +
  geom_histogram(aes(x = ConditionA03), stat = "bin", bins = 200) +
  xlab("Raw expression counts") +
  ylab("Number of genes")+
  scale_x_log10()

```

Here we can build a graph with several samples for the same condition
```{r}
ggplot(pivot%>%
         filter(grepl("ConditionL", name)))+
  geom_histogram(aes(x = value), stat = "bin", bins = 200) +
  xlab("Raw expression counts") +
  ylab("Number of genes")+
  scale_x_log10()+
  facet_wrap(~name)

```

We might try to check the normalized in the same way and compare ...


################################################Going on with DEseq pipeline####################################################
Load the metadata for Schistocephalus

```{r}
SScolData <- read.table("~/data/schistoData.txt")
```

And Now I can start loading the data in DEseq2 but first let's check:
```{r}
head(SchistoFCounts$counts)
```

```{r}
SScolData
```

These two files need to have the samples named in the same way so we have to remove the .bam from SchistoFCounts
```{r}
colnames(SchistoFCounts$counts) <- sub(".bam", "", colnames(SchistoFCounts$counts))
head(SchistoFCounts$counts)
```

Loading the tables in DEseq2
I would put here the design already: ~ Host so then we run the model directly
Also we put Free as reference level and we have to specify it in the colData loading
```{r}
str(SScolData)
SScolData$Host <- as.factor(SScolData$Host)
SScolData$Unique_name <- as.factor(SScolData$Unique_name)
SScolData$Stage <- as.factor(SScolData$Stage)
SScolData$Condition <- as.factor(SScolData$Condition)
SScolData <- droplevels(SScolData, exclude = if(anyNA(levels(SScolData))) NULL else NA) ####There is no need to do that later?
SSDEseq <- DESeqDataSetFromMatrix(
  countData = SchistoFCounts$counts,
  colData = SScolData,
  design=~1)
#############I've put no design here, cause I just want to check the data in the following steps. I should maybe create another script for the model testing, in which i create matrix for each model and use it in the LRT as argument of the full=design(matrix) that can be m1, m2, m3 and bla. Clean the environments!!!! 
```

#############I've put no design here, cause I just want to check the data in the following steps. I should maybe create another script for the model testing, in which i create matrix for each model and use it in the LRT as argument of the full=design(matrix) that can be m1, m2, m3 and bla. Clean the environments!!!! 
#######################################################################################################################################################################################################################################################################################################################################


Let's remove the genes that are counted less than 10 times in all the samples
For now ok, but then decide the threshold base on a reason, why 10? why 20? For the sum of the samples? At least how many? Make several try. Always do things that you can justify
```{r}
keep <- rowSums(counts(SSDEseq)) >= 10
SSDEseq <- SSDEseq[keep,]
```




#############Quality checks on the data loaded#################DEseq pipeline##################################


Let's plot sd vS mean of each gene to see if the range of variance is the same at different ranges of mean, so to see if they are homoskedastic:
```{r}
lambda <- 10^seq(from = -1, to = 2, length = 1000) ###here, Poisson counts with a range of lambda from 0.1 to 100
SSmatrix <- matrix(rpois(1000*100, lambda), ncol = 100)
library("vsn")
meanSdPlot(SSmatrix, ranks = TRUE)
```

They are not, and this is normal for RNA-seq data, cause lowly expressed genes will have a low range of variance, and this will reflect on the PCA or other exploratory analysis, so we need to transform the data:
I'm gonna apply the vst transformation cause I have more tha 50 samples and because ...
And I will run it blind so the variance doesn't get overestimated by the sample size
(look into it)
```{r}
SSDEseqvst <- vst(SSDEseq, blind = TRUE)
head(assay(SSDEseqvst), 3)
```

Let's see how it looks now

```{r}
meanSdPlot(assay(SSDEseqvst), rank=TRUE)
```

And plotting 2 random genes:
```{r}
SSvstdf <- as_data_frame(assay(SSDEseqvst)[, 1:2]) %>% mutate(transformation = "vst")
colnames(SSvstdf)[1:2] <- c("x", "y") 
lvls <- c("vst")
SSvstdf$transformation <- factor(SSvstdf$transformation, levels = lvls)
ggplot(SSvstdf, aes(x=x, y=y))+geom_hex(bins=80)+
  coord_fixed()
```
I'm not sure how to interpret this... I'm not too convinced is good enough, but this is only for preliminary visualization

Let's calculate the distance matrix between samples and plot it to have an idea of the grouping:
```{r}
SSDist <- dist(t(assay(SSDEseqvst)))
```

With an heatmap for example:

```{r}
library("pheatmap")
library("RColorBrewer")
SSDistM <- as.matrix( SSDist )
rownames(SSDistM) <- paste(SScolData$Condition)
colnames(SSDistM) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(SSDist,
         clustering_distance_rows = SSDist,
         clustering_distance_cols = SSDist,
         col = colors)
```
We would need an indication of what they are ... like names, but it's easier just look at the PCA:
```{r}
plotPCA(SSDEseqvst, intgroup=("Condition"))
```

Let's check more details on the samples:
```{r}
SSPCAdata <- plotPCA(SSDEseqvst, intgroup=c("Host", "Stage"), returnData=TRUE) ##ReturnData means do not plot but return them
SSpercentVar <- round(100*attr(SSPCAdata, "SSpercentVar")) ####Why is this empty?
ggplot(SSPCAdata, aes(PC1, PC2, color=Stage, shape=Host))+
  geom_point(size=3)+
  xlab(paste0("PC1: ", SSpercentVar[1], "% variance")) +
  ylab(paste0("PC2: ", SSpercentVar[2], "% variance")) +
  coord_fixed()
```

Let's make it nice for the poster:
```{r}
SSPCAdata <- plotPCA(SSDEseqvst, intgroup=c("Host", "Stage"), returnData=TRUE) ##ReturnData means do not plot but return them

SSntop=500
  SSv <- rowVars(assay(SSDEseqvst))
  SSselect <- order(SSv, decreasing = TRUE)[seq_len(min(SSntop,
                                                     length(SSv)))]
 ############## SSpca <- prcomp(t(assay(SSDEseqvst)[SSselect, ])) ###This is not necessary if I use SSPCAdata. Are these equivalent? I think so
  
  SSpercentVar <- SSPCAdata$sdev^2/sum(SSPCAdata$sdev^2)
  SSpercentVar <- round(SSpercentVar[1:2]*100,0)

  
SSpcaplot <- ggplot(SSPCAdata, aes(PC1, PC2, color=Stage, shape=Host))+
  geom_point(size=5)+
  xlab(paste0("PC1: ", SSpercentVar[1], "% variance")) +
  ylab(paste0("PC2: ", SSpercentVar[2], "% variance")) +
  scale_shape_manual(values = c("Copepod" = 15, 
                                "Free" = 17, 
                                "Stickleback" = 16,
                                "Bird" = 4)) +
  scale_color_manual(values = c("Growing" = "gray0",
                                "Infecting"= "firebrick",
                                "Reproducing"= "goldenrod3",
                                "Transmission" = "darkgreen",
                                "Growing-Transmission" = "cyan4")) +
  coord_fixed()+
  theme_bw()+
  theme(text = element_text(size = 15))+
  theme(panel.grid = element_blank(), panel.border = element_blank(), axis.line=element_line(), panel.background = element_rect(fill="transparent"), plot.background = element_rect(fill = "transparent"), legend.background = element_rect("transparent"), legend.key = element_rect(fill="transparent"))

############To save the pics:
#tiff(filename = "SSpca.tiff", width = 5, height = 4, units = "in", res = 1200, compression ="lzw")+
#png(filename = "SSpca.png", width = 5, height = 4, units = "in", res = 1200)  

#Or
#ggsave(SSpcaplot, 
#       filename = "SSpca.png",
#       bg = "transparent")
#But this doesn't allow to customize the resolution  
```


Multi-dimensional-scaling MDS:
```{r}
SSmds <-as.data.frame(colData(SSDEseqvst))  %>%
         cbind(cmdscale(SSDistM))
ggplot(SSmds, aes(x = `1`, y = `2`, color = Stage, shape = Host, size=Pop)) +
  geom_point() + coord_fixed() + ggtitle("MDS with vst data")

```

To visualize some hetmap as additional explorative analysis:
```{r}
library("genefilter")
SStopvargenes <- head(order(rowVars(assay(SSDEseqvst)), decreasing = TRUE), 10) ##Select the 10 genes that bring more variance
SSmat <- assay(SSDEseqvst)[SStopvargenes, ]
SSmat <- SSmat - rowMeans(SSmat)
SS20genes <- as.data.frame(colData(SSDEseqvst)[,c("Stage", "Host")]) ##I can play with this filtering out the other pop and the samples from Hebert to see how it changes
pheatmap(SSmat, annotation_col = SS20genes)
```
########################################################END OF VISUALIZATION/QUALITY CHECKS ################################################

The design is already in the object (~ Host+Stage) and with the Free living stage and Transmission as ref level/intercept
Let's try to fit this model
```{r}
SSDEhost <- DESeq(SSDEseq)
SSDEhost
```

And then in the results I can pull out the comparisons I want. It should recalculate each time the different column. Check on that and study the DE command!!!
```{r}
SSresHOST <- results(SSDEhost)
summary(SSresHOST)
```
By the default it shows a random comparison

Let's see the names of the models (?)
```{r}
resultsNames(SSDEhost)
```
They are all against the free stage that I put with as reference, but by changing the results specification I can make the other comparisons:

Now we try using contrast, we compare 2 condition (Model for the host, we compare first and 2nd intermediate host)
And we filter out the NA adj p value genes, cause they are very low expressed
```{r}
COBIRD <- results(SSDEhost, contrast = c("Host", "Copepod", "Bird"))
nrow((COBIRD))
sum(is.na(COBIRD$padj))
COBIRD <- COBIRD[!is.na(COBIRD$padj),]
nrow(COBIRD)
```

Now we filter only the significant, assuming that 1% are false positives
```{r}
sigCOBIRD <- COBIRD[which(COBIRD$padj < 0.0001),]
nrow(sigCOBIRD)
```
These are the significant differentially expressed genes. They are too many, rank them

```{r}
sigCOBIRD <- sigCOBIRD[ order(sigCOBIRD$padj), ]
sigCOBIRD <- as.data.frame(sigCOBIRD)
head(sigCOBIRD, n=20)
```


```{r}
plotMA(sigCOBIRD)
```

```{r}
FREECO <- results(SSDEhost, contrast = c("Host", "Free", "Copepod"))
nrow(FREECO)
sum(is.na(FREECO$padj))
FREECO <- FREECO[!is.na(FREECO$padj),]
nrow(FREECO)
```

Now we filter only the significant, assuming that 1% are false positives
```{r}
sigFREECO <- FREECO[which(FREECO$padj < 0.01),]
nrow(sigFREECO)
```
These are the significant differentially expressed genes. They are too many, rank them

```{r}
sigFREECO <- sigFREECO[ order(sigFREECO$padj), ]
sigFREECO <- as.data.frame(sigFREECO)
head(sigFREECO, n=20)
```


#########################################TO GO ON AND PLAYING WITH POST-FILTERING. ALSO DIFFERENT COMPARISONS, HOW DOES IT WORK? IS IT ONLY 2 AT THE TIME???

To try with the interaction we have to modify the data first
First we should remove, the levels that do not have samples (we do this in the DEDataSet)
Probably there is no need for this, cause I did it in the beginning (after loading the data)
```{r}
SSDEseq$Host <- droplevels(SSDEseq$Host)
##SScolData$Stage <- droplevels(SScolData$Host)
SSDEseq$Stage <- droplevels(SSDEseq$Stage)
###SScolData$Stage <- droplevels(SScolData$Stage)
```

Then we remove the 0 when a combination of level is missing for example: Reproduction in Stickleback
And we do this in the colData
We rearrange the model:
```{r}
m1 <- model.matrix(~Stage+Host+Stage:Unique_name+Host:Unique_name+Stage:Host, SScolData)
```
This will produce a lot of zeros because there are missing combinations. We can remove the zeros from the matrix and then pass it on to the full argument of the DEseq. 

```{r}
colnames(m1)
unname(m1)
```


```{r}
all.zero <- apply(m1, 2, function(x) all(x==0))
all.zero
```

```{r}
idx <- which(all.zero)
m1 <- m1[, -idx]
unname(m1)
colnames(m1)
```

```{r}
SSDEhostaint <- DESeq(SSDEseq, full=design(m1), betaPrior = FALSE)
```

```{r}
SSDEseq <- DESeqDataSetFromMatrix(
  countData = SchistoFCounts$counts,
  colData = SScolData,
  design= ~ Condition)
```
```{r}
ConditionM <- DESeq(SSDEseq)
```
```{r}
res <- results(ConditionM)
summary(res)
```

```{r}
res
```

```{r}
M1 <- model.matrix(~Host, SScolData)
```


##########################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################PUT ORDER AND REDO THE THINGS!!!###########
################################################FORM HERE WE START###########

######################Test again the models
First we load the data putting the Host as design
```{r}
M1 <- DESeqDataSetFromMatrix(
  countData = SchistoFCounts$counts,
  colData = SScolData,
  design= ~ Host)
```

The we use DEseq with the likelihood ratio test to compare the Host model with the intercept

```{r}
HostM1 <- DESeq(M1, test="LRT", reduced = ~1)
```
Calculate the results

```{r}
resultsM1 <- results(HostM1)
```
Load the data with Stage as design: M2
```{r}
M2 <- DESeqDataSetFromMatrix(
  countData = SchistoFCounts$counts,
  colData = SScolData,
  design= ~ Stage)
```

Test Stage against intercept

```{r}
StageM2 <- DESeq(M2, test="LRT", reduced = ~1)
```

Calculate the results 

```{r}
resultsM2 <- results(StageM2)
```


Load the data with Host and Stage against the intercept: M3

```{r}
M3 <- DESeqDataSetFromMatrix(
  countData = SchistoFCounts$counts,
  colData = SScolData,
  design= ~ Host + Stage)
```

Now Test the M3 model (Host + Stage) against the intercept

```{r}
HostStageM3 <- DESeq(M3, test="LRT", reduced = ~ Host + Stage)
resultsM3 <- results(ConditionM3)
```

#######This one doesn't work###

Load the data with Design condition. It doesn't work, we have to first create the matrix: condmatrix
```{r}
condmatrix <- model.matrix(~Condition, SScolData)
M4 <- DESeqDataSetFromMatrix(
  countData = SchistoFCounts$counts,
  colData = SScolData,
  design= condmatrix)
```


##########Since we used a matrix I have to also put the term I'm removing as a matrix, so here is the matrix for the Host variable
```{r}
Hostmatrix <- model.matrix(~Host, SScolData)
```

Now we test the the condition and the Host
```{r}
ConditionM4 <- DESeq(M4, test = "LRT", reduced = Hostmatrix)
```
```{r}
resultsM4 <- results(ConditionM4)
```

Now with the same data loaded in M4 (design ~ condition) we test against the stage, so we need a stage matrix


```{r}
Stagematrix <- model.matrix(~Stage, SScolData)
```

And then we test
```{r}
ConditionM4.1 <- DESeq(M4, test = "LRT", reduced = Stagematrix)
resultsM4.1 <- results(ConditionM4.1)
```



Now I have to create a data frame to plot and compare the models. So I have to take the adjpvalues. I'll make 1 column with the genes, one column with the models and one column with the adjusted p values.

```{r}
int_host <- as.data.frame(resultsM1)
int_stage <- as.data.frame(resultsM2)
host_condition <- as.data.frame(resultsM4)
stage_condition <- as.data.frame(resultsM4.1)


adjp <- dplyr::lst(int_host, int_stage, host_condition, stage_condition) %>% 
  set_names(c("int_host", "int_stage", "host_condition", "stage_condition")) %>% 
  bind_rows(.id = "Model")
```

Plot the adjpvalues


```{r}
colSums(apply(adjp, 2, "<", 0.05), na.rm =T)
```


```{r}
ggplot(modelspvalues) +
  geom_density(aes(x=m1), stat="density", fill="blue", kernel="gaussian")+
  geom_density(aes(x=m2), stat="density", fill="yellow", kernel="gaussian")+
  geom_density(aes(x=m3), stat="density", fill="black", kernel="gaussian")+
  geom_density(aes(x=m4), stat = "density", fill="pink", kernel="gaussian")+
  geom_density(aes(x=m4.1), stat="density", fill="red", kernel="gaussian")+
  geom_density(aes(x=m4.2), stat="density", fill="green", kernel="gaussian")+
  xlab("p-values") +
  ylab("count") +
  xlim(0, 0.05) +
  ylim(0, 60)

colSums(apply(adjp, 2, "<", 0.05), na.rm =T)

```














































```{r}
modelspvalues <- data.frame(row.names(resultsM1), resultsM1$padj, resultsM2$padj, resultsM3$padj, resM4$padj, resultsM4.1$padj, resultsM4.2$padj)
modelspvalues <- rename(modelspvalues, m1=resultsM1.padj, m2=resultsM2.padj, m3=resultsM3.padj, m4=resM4.padj, m4.1=resultsM4.1.padj, m4.2=resultsM4.2.padj) 
```

Plot the p-values of each gene for each model
```{r}
ggplot(modelspvalues) +
  geom_density(aes(x=m1), stat="density", fill="blue", kernel="gaussian")+
  geom_density(aes(x=m2), stat="density", fill="yellow", kernel="gaussian")+
  geom_density(aes(x=m3), stat="density", fill="black", kernel="gaussian")+
  geom_density(aes(x=m4), stat = "density", fill="pink", kernel="gaussian")+
  geom_density(aes(x=m4.1), stat="density", fill="red", kernel="gaussian")+
  geom_density(aes(x=m4.2), stat="density", fill="green", kernel="gaussian")+
  xlab("p-values") +
  ylab("count") +
  xlim(0, 0.05) +
  ylim(0, 60)
colSums(apply(modelspvalues, 2, "<", 0.05), na.rm =T)


```


```{r}
ggplot(modelspvalues) +
  geom_density(aes(x=m1), stat="density", fill="blue", kernel="gaussian")+
  geom_density(aes(x=m2), stat="density", fill="yellow", kernel="gaussian")+
  geom_density(aes(x=m3), stat="density", fill="black", kernel="gaussian")+
  geom_density(aes(x=m4), stat = "density", fill="pink", kernel="gaussian")+
  geom_density(aes(x=m4.1), stat="density", fill="red", kernel="gaussian")+
  geom_density(aes(x=m4.2), stat="density", fill="green", kernel="gaussian")+
  xlab("p-values") +
  ylab("count") +
  scale_x_log10()
  
```


```{r}
ggplot(modelspvalues) +
  geom_density(aes(x=m1), stat="density", color="green")+
  geom_density(aes(x=m2), stat="density", color="yellow")+
  geom_density(aes(x=m3), stat="density", color="red")+
  geom_density(aes(x=m4), stat = "density", color="pink")+
  geom_density(aes(x=m4.1), stat="density", color="blue")+
  geom_density(aes(x=m4.2), stat="density", color="black")+
  xlab("p-values") +
  ylab("count") +
  ylim(0, 60)+
  xlim(0.004, 0.05)
```


```{r}
as.data.frame(resultsM1) %>% 
ggplot() +
  geom_density(aes(x=pvalue), stat="density", fill="blue", kernel="gaussian") +
  xlim(0, 0.00001)
```



```{r}
plotMA(resultsM1, ylim=c(-2,2))
```

```{r}
plotMA(resultsM3, ylim=c(-2,2))
```

```{r}
as.data.frame(resultsM1) %>% 
ggplot(aes(x=log2FoldChange, y=-log10(pvalue))) + 
         geom_point()
```

```{r}
as.data.frame(resultsM1) %>% 
ggplot() +
  geom_smooth(aes(x=pvalue, y=log2FoldChange))
```


















```{r}
use <- resultsM1$baseMean > metadata(resultsM1)$filterThreshold
h1 <- hist(resultsM1$pvalue[!use], breaks=0:50/50, plot=FALSE)
h2 <- hist(resultsM2$pvalue[use], breaks=0:50/50, plot=FALSE)
colori <- c(`do not pass`="khaki", `pass`="powderblue")
```

```{r}
barplot(height = rbind(h1$counts, h2$counts), beside = FALSE,
        col = colori, space = 0, main = "", ylab="frequency")
text(x = c(0, length(h1$counts)), y = 0, label = paste(c(0,1)),
     adj = c(0.5,1.7), xpd=NA)
legend("topright", fill=rev(colori), legend=rev(names(colori)))
```







Probably you should pivot the dataframe, and it would be easier
```{r}

```





