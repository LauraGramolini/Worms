---
title: "SS_DEmodels"
author: "Laura Gramolini"
date: '2022-09-21'
output: html_document
---

Here we test the models
First we load the data putting the Host as design. I would load the data everytime and change the design, probably not the best but the easiest way.

```{r}
SScountdf <- read.csv("~/GitHub/Worms/data/SScountdf.csv", header = TRUE, sep="")
```


M1 would be the dataset loaded in DEseq with the Host as design
```{r}
M1 <- DESeqDataSetFromMatrix(
  countData = SchistoFCounts$counts,
  colData = SScolData,
  design= ~ Host)
```

The we use DEseq with the likelihood ratio test to compare the Host model with the intercept

```{r}
HostM1 <- DESeq(M1, test="LRT", reduced = ~1)
```
Calculate the results

```{r}
resultsM1 <- results(HostM1)
```
Load the data with Stage as design: M2
```{r}
M2 <- DESeqDataSetFromMatrix(
  countData = SchistoFCounts$counts,
  colData = SScolData,
  design= ~ Stage)
```

Test Stage against intercept

```{r}
StageM2 <- DESeq(M2, test="LRT", reduced = ~1)
```

Calculate the results 

```{r}
resultsM2 <- results(StageM2)
```


Load the data with Host and Stage interaction (Condition) against the intercept: M3

```{r}
M3 <- DESeqDataSetFromMatrix(
  countData = SchistoFCounts$counts,
  colData = SScolData,
  design= ~ Condition)
```

Now Test the M3 model (Host + Stage) against the intercept

```{r}
HostStageM3 <- DESeq(M3, test="LRT", reduced = ~ Condition)
resultsM3 <- results(ConditionM3)
```
################Solve this

Load the data with Design condition. It doesn't work, we have to first create the matrix: condmatrix
```{r}
condmatrix <- model.matrix(~Condition, SScolData)
M4 <- DESeqDataSetFromMatrix(
  countData = SchistoFCounts$counts,
  colData = SScolData,
  design= condmatrix)
```


##########Since we used a matrix I have to also put the term I'm removing as a matrix, so here is the matrix for the Host variable
```{r}
Hostmatrix <- model.matrix(~Host, SScolData)
```

Now we test the the condition and the Host
```{r}
ConditionM4 <- DESeq(M4, test = "LRT", reduced = Hostmatrix)
```
```{r}
resultsM4 <- results(ConditionM4)
```

Now with the same data loaded in M4 (design ~ condition) we test against the stage, so we need a stage matrix


```{r}
Stagematrix <- model.matrix(~Stage, SScolData)
```

And then we test
```{r}
ConditionM4.1 <- DESeq(M4, test = "LRT", reduced = Stagematrix)
resultsM4.1 <- results(ConditionM4.1)
```



Now I have to create a data frame to plot and compare the models. So I have to take the adjpvalues. I'll make 1 column with the genes, one column with the models and one column with the adjusted p values.

```{r}
int_host <- as.data.frame(resultsM1)
int_stage <- as.data.frame(resultsM2)
host_condition <- as.data.frame(resultsM4)
stage_condition <- as.data.frame(resultsM4.1)


adjp <- dplyr::lst(int_host, int_stage, host_condition, stage_condition) %>% 
  set_names(c("int_host", "int_stage", "host_condition", "stage_condition")) %>% 
  bind_rows(.id = "Model")
```


Try here to test the condition model alone, and extract the differentially expressed genes
```{r}

```




























Plot the adjpvalues


```{r}
colSums(apply(adjp, 2, "<", 0.05), na.rm =T)
```


```{r}
ggplot(adjp, aes(x=padj, color = Model)) + 
         geom_density()
  
```

```{r}
filter(adjp, !is.na(padj)) %>%
ggplot(aes(x=padj, color = Model)) + 
         geom_histogram()
```

Pvalues Plots, fail

Try to set a threshold to filter the FDR
```{r}
sum(adjp$padj < 0.1, na.rm=TRUE)
```

```{r}

```





geom_density(aes(x=m1), stat="density", fill="blue", kernel="gaussian")+
  geom_density(aes(x=m2), stat="density", fill="yellow", kernel="gaussian")+
  geom_density(aes(x=m3), stat="density", fill="black", kernel="gaussian")+
  geom_density(aes(x=m4), stat = "density", fill="pink", kernel="gaussian")+
  geom_density(aes(x=m4.1), stat="density", fill="red", kernel="gaussian")+
  geom_density(aes(x=m4.2), stat="density", fill="green", kernel="gaussian")+
  xlab("p-values") +
  ylab("count") +
  xlim(0, 0.05) +
  ylim(0, 60)

colSums(apply(adjp, 2, "<", 0.05), na.rm =T)
```{r}
plotMA(resultsM1, ylim=c(-2,2))
```

```{r}
plotMA(resultsM3, ylim=c(-2,2))
```

```{r}
as.data.frame(resultsM1) %>% 
ggplot(aes(x=log2FoldChange, y=-log10(pvalue))) + 
         geom_point()
```

```{r}
as.data.frame(resultsM1) %>% 
ggplot() +
  geom_smooth(aes(x=pvalue, y=log2FoldChange))
```


















```{r}
use <- resultsM1$baseMean > metadata(resultsM1)$filterThreshold
h1 <- hist(resultsM1$pvalue[!use], breaks=0:50/50, plot=FALSE)
h2 <- hist(resultsM2$pvalue[use], breaks=0:50/50, plot=FALSE)
colori <- c(`do not pass`="khaki", `pass`="powderblue")
```

```{r}
barplot(height = rbind(h1$counts, h2$counts), beside = FALSE,
        col = colori, space = 0, main = "", ylab="frequency")
text(x = c(0, length(h1$counts)), y = 0, label = paste(c(0,1)),
     adj = c(0.5,1.7), xpd=NA)
legend("topright", fill=rev(colori), legend=rev(names(colori)))
```







Probably you should pivot the dataframe, and it would be easier
```{r}

```





