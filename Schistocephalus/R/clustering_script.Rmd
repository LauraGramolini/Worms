---
title: "Clustering of genes by expression profiles"
output: 
  github_document:
    toc: true
    df_print: kable
---

This script will cluster genes that have similar patterns of expression.

```{r setup, include=FALSE}
library(tidyverse)
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)
options(stringsAsFactors = FALSE)
theme_set(theme_bw())
theme_update(panel.grid.minor = element_blank())
```

First, we load the gene count table for *Schistocephalus solidus*.

```{r}
gc <- read.table(file = "../data/SScountdf.csv", header = T, sep = " ") # gene count
md <- read.delim(file = "../data/schistoData.txt", header = T) # metadata
md <- select(md, -X)
```

There are ~20,000 genes from 72 samples.

```{r}
dim(gc)
```

```{r}
# add gene name to data
gc$gene <- row.names(gc)
```

# Filtering genes with low expression

The data are in wide format with each column representing a sample and each row a gene. We will make the data long, so that each combination of gene and sample has its own row (i.e. all expression counts are in a single column).

```{r}
gc_long <- gc%>%
  pivot_longer(cols = starts_with("Condition"), names_to = "sample", values_to = "counts")

gc_long <- gc_long%>%
  mutate(grp = gsub(pattern = "[:0-9:]", "", x = gc_long$sample))
```

Here is the distribution of counts for every gene in every sample. In most samples in most genes, no expression is detectable. 

```{r}
ggplot(gc_long, aes(x = counts+.1)) +
  geom_histogram(bins = 60) +
  scale_x_log10()
```

When we exclude the zeros (no expression), we see a bimodal distribution. In many genes in many samples, counts are low (peak at one) and probably just represent noise. The peak at higher values probably represents "real" expression, say greater than 10 counts per gene.

```{r}
ggplot(gc_long%>%filter(counts>0), aes(x = counts)) +
  geom_histogram(bins = 60) +
  scale_x_log10(breaks = c(1, 10, 100, 1000, 10000))
```
The pattern is similar within each of our treatment groups. There is a fair amount of low-level expression that is probably just noise, and then from 10 counts or so there seems to be genuine expression. The separate lines are for the different samples. They show that the distribution of expression counts is similar across replicates.

```{r}
ggplot(gc_long, aes(x = counts)) +
  geom_density(aes(group = sample), 
               color = "gray", fill = "pink", alpha = 0.1) +
  scale_x_log10(breaks = c(1, 10, 100, 1000)) +
  facet_wrap(~grp)
```

We can take the median expression level for each gene in each condition and make the same plot. Clearly some of the low-level expression can be removed.

```{r}
gc_avg_by_condition <- gc_long%>%
  group_by(grp, gene)%>%
  summarise(median = median(counts),
            min = min(counts))
```
```{r}
ggplot(gc_avg_by_condition, aes(x = median)) +
  geom_density(color = "gray", fill = "pink", alpha = 0.1) +
  scale_x_log10(breaks = c(1, 10, 100, 1000)) +
  facet_wrap(~grp)
```
```{r}
# for each gene take the maximum median expression level for any given condition
gc_max_exp_in_at_least_cond <- gc_avg_by_condition%>%
  group_by(gene)%>%
  summarise(max_med_count = max(median))

# ggplot(gc_max_exp_in_at_least_cond, aes(x = max_med_count)) +
#   geom_density(color = "gray", fill = "pink", alpha = 0.1) +
#   scale_x_log10(breaks = c(1, 10, 100, 1000))
```

As an arbitrary threshold, we will remove genes that do not have a median expression level of at least 10 counts in at least one condition.

```{r}
low_genes <- gc_max_exp_in_at_least_cond%>%
  filter(max_med_count < 10)%>%.$gene
```

Here is the percent of genes removed.

```{r}
round(length(low_genes)/length(gc$gene), 3)
```

Doubling the threshold for expression counts (20) only removes a few percent more.

```{r}
low_genes20 <- gc_max_exp_in_at_least_cond%>%
  filter(max_med_count < 20)%>%.$gene
round(length(low_genes20)/length(gc$gene), 3)
```

Similarly halving the threshold (5) would only add a few percent of the genes back into the analysis.

```{r}
low_genes5 <- gc_max_exp_in_at_least_cond%>%
  filter(max_med_count < 5)%>%.$gene
round(length(low_genes5)/length(gc$gene), 3)
```

Specifically, it would add this many genes back into the analysis:

```{r}
length(low_genes)-length(low_genes5)
rm(low_genes20, low_genes5)
```

# All expressed genes

```{r}
# reduce gene count to expressed genes
gc_expressed <- gc%>%
  filter(!gene %in% low_genes)
```

Now that we have a list of expressed genes, we want to make them comparable before clustering. Specifically, expression counts are usually overdispersed, with the variance increasing with the mean. Therefore, for clustering, it is [recommended](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#data-transformations-and-visualization) to transform the data. The package `DESeq2` provides a function for this `vst`.

```{r}
gc_expressed_trans <- DESeq2::vst(
  gc_expressed%>%select(-gene)%>%as.matrix()
  )
```

The variance stabilizing transforms the data but it is kept on a log scale. That is, genes that are highly expressed should still have high values compared to lowly expressed genes. We can see this by plotting the gene-level relationship between mean expression before and after transformation. Looks similar to a log-transformation.

```{r}
mean_expr_untrans <- rowMeans(
  gc_expressed%>%select(-gene)%>%as.matrix()
)

mean_expr_trans <- rowMeans(gc_expressed_trans)

qplot(mean_expr_untrans, mean_expr_trans)
rm(mean_expr_untrans, mean_expr_trans)
```

```{r}
# put transformed values into long format
gc_expressed_trans_long <- as.data.frame(gc_expressed_trans)
gc_expressed_trans_long$gene <- row.names(gc_expressed_trans_long)
gc_expressed_trans_long <- gc_expressed_trans_long%>%
  pivot_longer(cols = starts_with("Condition"), names_to = "sample", values_to = "trans_counts")%>%
  mutate(grp = gsub(pattern = "[:0-9:]", "", x = sample))

gc_expressed_trans_long <- gc_expressed_trans_long%>%
  left_join(., 
            md%>%select(Unique_name, func=Stage, host=Host),
            by = c("sample" = "Unique_name")
            )
gc_expressed_trans_long <- gc_expressed_trans_long%>%
  group_by(gene, grp, func, host)%>%
  summarise(trans_counts = median(trans_counts))
```

We can already run a clustering analysis on this data, but we have to accept that this may simply lump together highly vs lowly expressed genes. With the transformed, scaled expression data, we calculate the euclidean distance between each gene. This distance matrix is then fed to the hierarchical clustering algorithm. The clustering method is 'complete linkage' which aims to put genes into similar clusters.

```{r}
gene_dist <- dist(gc_expressed_trans)
gene_hclust <- hclust(gene_dist, method = "complete")

# # plot dendogram
# plot(gene_hclust, labels = FALSE)
# abline(h = 10, col = "brown", lwd = 2)
```

After running the clustering algorithm, we would like to visualize the clusters. Let's take the first 10 clusters.

```{r}
clusters <- cutree(gene_hclust, k = 10)

clusters <- clusters%>%
  enframe() %>% 
  rename(gene = name, cluster = value)
```

Here are the number of genes in each cluster. Some of the clusters have rather few genes:

```{r}
table(clusters$cluster)
```

We add the clusters to the transformed expression data for plotting.

```{r}
# add cluster to main data
gc_expressed_trans_clusters <- gc_expressed_trans_long%>%
  left_join(., clusters)
```

The time-course of the gene expression is then plotted. We can see how the first four clusters just separate genes with different expression levels. Other clusters, though, distinguish genes that are up or down regulated at the beginning or end of the life cycle.

```{r}
x_ax_lab <- c("free", "cop-inf", "cop-grow", "cop-trans", "fish-inf", "fish-grow", "fish-grow2"
, "fish-trans", "bird-inf", "bird-repr")

ggplot(gc_expressed_trans_clusters%>%
         ungroup(), 
       aes(x = grp, y = trans_counts)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_point(aes(color = trans_counts), alpha = 0.1) +
  # geom_line(aes(group = gene), alpha = 0.1) +
  geom_line(stat = "summary",
            fun = "median", colour = "black", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```

Clustering genes that just have high or low expression is not particularly interesting. Rather, we are more interested in patterns of co-expression across the life cycle, i.e. genes that show similar patterns of increasing and decreasing expression. Therefore, we scale the transformed expression values to a z-score for each gene.

```{r}
gc_expressed_trans <- gc_expressed_trans%>% 
  # transpose the matrix so genes are as columns
  t() %>% 
  # apply scaling to each column of the matrix (genes)
  scale() %>% 
  # transpose back so genes are as rows again
  t()
```

```{r}
# put z-scores into long format
gc_expressed_trans_long <- as.data.frame(gc_expressed_trans)
gc_expressed_trans_long$gene <- row.names(gc_expressed_trans_long)
gc_expressed_trans_long <- gc_expressed_trans_long%>%
  pivot_longer(cols = starts_with("Condition"), names_to = "sample", values_to = "zscore")%>%
  mutate(grp = gsub(pattern = "[:0-9:]", "", x = sample))

gc_expressed_trans_long <- gc_expressed_trans_long%>%
  left_join(., 
            md%>%select(Unique_name, func=Stage, host=Host),
            by = c("sample" = "Unique_name")
            )
gc_expressed_trans_long <- gc_expressed_trans_long%>%
  group_by(gene, grp, func, host)%>%
  summarise(z_score = median(zscore))
```

With the transformed, scaled expression data, we again calculate the euclidean distance between each gene and give this distance matrix to the clustering algorithm.

```{r}
gene_dist <- dist(gc_expressed_trans)
gene_hclust <- hclust(gene_dist, method = "complete")
```

```{r}
# # plot dendogram
# plot(gene_hclust, labels = FALSE)
# abline(h = 10, col = "brown", lwd = 2)
```

After running the clustering algorithm, we would like to visualize the clusters. Let's again take the first 10 clusters.

```{r}
clusters <- cutree(gene_hclust, k = 10)

clusters <- clusters%>%
  enframe() %>% 
  rename(gene = name, cluster = value)
```

Here are the number of genes in each cluster:

```{r}
table(clusters$cluster)
```

After adding the clusters to the transformed expression data, the time-course of expression is plotted.

```{r}
# add cluster to main data
gc_expressed_trans_clusters <- gc_expressed_trans_long%>%
  left_join(., clusters)
```

Some trends are notable, such as clusters with increased expression in birds or the free stages.

```{r}
# x_ax_lab <- gc_expressed_trans_clusters%>%
#   ungroup()%>%
#   mutate(stage_name = paste0(substr(host, 1, 3), "-", substr(func, 1, 3)))%>%
#   select(stage_name)%>%
#   distinct()%>%.$stage_name
x_ax_lab <- c("free", "cop-inf", "cop-grow", "cop-trans", "fish-inf", "fish-grow", "fish-grow2"
, "fish-trans", "bird-inf", "bird-repr")
```

```{r}
ggplot(gc_expressed_trans_clusters%>%
         ungroup(), 
       aes(x = grp, y = z_score)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_point(aes(color = z_score), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  # geom_line(aes(group = gene), alpha = 0.1) +
  geom_line(stat = "summary",
            fun = "median", colour = "black", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```

## How many clusters

Ten clusters was arbitrary. One way to estimate how many clusters there are in the data is to perform a faster clustering algorithm (kmeans) with different numbers of pre-defined clusters. Then, we can see how the variance within clusters decreases as a function of the number of clusters. Here is the pattern:

```{r}
# function to compute total within-cluster sum of square 
wss <- function(k) {
  kmeans(gc_expressed_trans, k, nstart = 10 )$tot.withinss
}

# Compute and plot wss for k = 1 to k = 15
k.values <- 1:25

# extract wss for 2-15 clusters
wss_values <- map_dbl(k.values, wss)

qplot(k.values, wss_values) +
  geom_line() + 
  labs(x = "Number of clusters K", y = "Total within-clusters sum of squares") 
```

In this "elbow plot", we are looking for a break in the line (an elbow) where additional clusters do not reduce within cluster variance much. Unfortunately, the trend looks fairly linear on a log-scale, in that each additional cluster decreases variance proportionally. We can plot this. Perhaps there is a break at 4 and 7 clusters. 

```{r}
qplot(k.values, wss_values) +
  geom_line() + 
  labs(x = "Number of clusters K", y = "Total within-clusters sum of squares") +
  scale_x_log10()
```

Thus, let's go back to our hierarchical clustering, but now take the top 7 clusters. 

```{r}
clusters <- cutree(gene_hclust, k = 7)

clusters <- clusters%>%
  enframe() %>% 
  rename(gene = name, cluster = value)
```

Here are the number of genes in each cluster:

```{r}
table(clusters$cluster)
```
```{r}
# add cluster to main data
gc_expressed_trans_clusters <- gc_expressed_trans_long%>%
  left_join(., clusters)
```
Some patterns are still evident, but it is not clear that reducing the number of clusters "improved" the patterns.

```{r}
ggplot(gc_expressed_trans_clusters%>%
         ungroup(), 
       aes(x = grp, y = z_score)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_point(aes(color = z_score), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  # geom_line(aes(group = gene), alpha = 0.1) +
  geom_line(stat = "summary",
            fun = "median", colour = "black", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```

Taking much finer clusters also does not produce far clearer trends. Rather, some of the clusters are probably repeating.

```{r}
clusters <- cutree(gene_hclust, k = 20)

clusters <- clusters%>%
  enframe() %>% 
  rename(gene = name, cluster = value)

# add cluster to main data
gc_expressed_trans_clusters <- gc_expressed_trans_long%>%
  left_join(., clusters)

ggplot(gc_expressed_trans_clusters%>%
         ungroup(), 
       aes(x = grp, y = z_score)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_point(aes(color = z_score), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  # geom_line(aes(group = gene), alpha = 0.1) +
  geom_line(stat = "summary",
            fun = "median", colour = "black", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```

## Different clustering algorithms

Let's try a different clustering algorithm. Cluster membership can vary quite a lot between clustering algorithms (see [here](https://cran.r-project.org/web/packages/dendextend/vignettes/Cluster_Analysis.html)). Instead of 'complete linkage', we'll try 'average', which makes a UPGMA tree from the distance matrix. And again we'll take the top 7 clusters.

```{r}
gene_hclust <- hclust(gene_dist, method = "average")
# # plot dendogram
# plot(gene_hclust, labels = FALSE)

clusters <- cutree(gene_hclust, k = 7)

clusters <- clusters%>%
  enframe() %>% 
  rename(gene = name, cluster = value)
```

Here are the number of genes in each cluster - they are quite different from the 'complete linkage' algorithm:

```{r}
table(clusters$cluster)
```

```{r}
# add cluster to main data
gc_expressed_trans_clusters <- gc_expressed_trans_long%>%
  left_join(., clusters)
```

Changing the algorithm did not obviously result in better patterns.

```{r}
ggplot(gc_expressed_trans_clusters%>%
         ungroup(), 
       aes(x = grp, y = z_score)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_point(aes(color = z_score), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  # geom_line(aes(group = gene), alpha = 0.1) +
  geom_line(stat = "summary",
            fun = "median", colour = "black", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```

We can also try the Ward method (`method = Ward.D2`), which minimizes the variance. We take 7 clusters as above.

```{r}
gene_hclust <- hclust(gene_dist, method = "ward.D2")
# # plot dendogram
# plot(gene_hclust, labels = FALSE)

clusters <- cutree(gene_hclust, k = 7)

clusters <- clusters%>%
  enframe() %>% 
  rename(gene = name, cluster = value)
```

Here are the number of genes per cluster. Again, they diverge from the 'complete linkage' algorithm:

```{r}
table(clusters$cluster)
```

```{r}
# add cluster to main data
gc_expressed_trans_clusters <- gc_expressed_trans_long%>%
  left_join(., clusters)
```

The ward algorithm seems to yield clearer patterns, with sharper changes in expression at certain stage transitions.

```{r}
ggplot(gc_expressed_trans_clusters%>%
         ungroup(), 
       aes(x = grp, y = z_score)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_point(aes(color = z_score), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  # geom_line(aes(group = gene), alpha = 0.1) +
  geom_line(stat = "summary",
            fun = "median", colour = "black", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```

Finally, we can also try the 'single linkage' method in `hclust`.

```{r}
gene_hclust <- hclust(gene_dist, method = "single")
# # plot dendogram
# plot(gene_hclust, labels = FALSE)

clusters <- cutree(gene_hclust, k = 7)

clusters <- clusters%>%
  enframe() %>% 
  rename(gene = name, cluster = value)
```

But this approach does not seem to work at all, as all genes are placed into one cluster.

```{r}
table(clusters$cluster)
```

# Differentially expressed genes

One possible way to improve clustering would be to use only differentially expressed genes. Let's import the genes that differed in expression, as judged by `DESeq2` models.

```{r}
gc_degs <- read.table(file = "../data/DEGsmodels.csv", header = T, sep = " ") # diff. expressed genes from all models 
```
```{r}
# results from int-only model vs host model
gc_degs_host <- filter(gc_degs,
                      Model == "int_host", 
                      !is.na(padj))
# results from int-only model vs functional stage model
gc_degs_func <- filter(gc_degs,
                      Model == "int_stage", 
                      !is.na(padj))
# results from int-only model vs all devo stages model
gc_degs_all <- filter(gc_degs,
                      Model == "int_condition", 
                      !is.na(padj))
# results from host and function models vs all devo stages model
gc_degs_host_func <- filter(gc_degs,
                      Model %in% c("host_condition", "stage_condition"), 
                      !is.na(padj))
```

## DEGs among hosts

We start by just isolating genes that were differentially expressed among hosts. Here are the number of genes where counts were high enough that `DESeq2` performed a LRT:

```{r}
length(gc_degs_host$Gene)
```

Out of these, this number had low expression levels under our criteria above.

```{r}
sum(gc_degs_host$Gene %in% low_genes)
```

These low-expression genes are less likely to be differentially expressed (higher p-values): 

```{r}
ggplot(gc_degs_host, aes(x = padj+0.00000001)) +
  geom_density(aes(color = Gene %in% low_genes)) +
  labs(color = "Low expression") +
  scale_x_log10()
```

So, with a conservative p-value threshold, many of these genes will be removed. Here are the number of DEGs at different levels of significance. A 10-fold change in the p-value usually removes roughly 1000 genes from the list.

```{r}
gc_degs_host%>%
  summarize(p0.01 = sum(padj < 0.01),
            p0.001 = sum(padj < 0.001),
            p0.0001 = sum(padj < 0.0001),
            p0.00001 = sum(padj < 0.00001),
            p0.000001 = sum(padj < 0.000001))
```

Let's only take the genes that had p-values less than 0.0001.

```{r}
degs_host <- filter(gc_degs_host, padj < 0.0001)%>%.$Gene
```

Here is an log-transformed elbow plot, based on kmeans clustering, with those genes. There are at least 3 or 4 clusters.

```{r}
# function to compute total within-cluster sum of square 
wss <- function(k) {
  kmeans(
    gc_expressed_trans[row.names(gc_expressed_trans) %in% degs_host,],
    k, nstart = 10 )$tot.withinss
}

# Compute and plot wss for k = 1 to k = 15
k.values <- 1:15

# extract wss for 2-15 clusters
wss_values <- map_dbl(k.values, wss)

qplot(k.values, wss_values) +
  geom_line() + 
  labs(x = "Number of clusters K", y = "Total within-clusters sum of squares") +
  scale_x_log10()
```

Now, we filter the count matrix to just the DEGs and we re-calculate the distance matrix, which is then fed into the clustering algorithm (`method = 'ward.D2'`). 

```{r}
gene_dist <- dist(
  # distance matrix for just degs_host
  gc_expressed_trans[
    row.names(gc_expressed_trans) %in% degs_host,
    ]
  )

gene_hclust <- hclust(gene_dist, method = "ward.D2")
```

Given the elbow plot, let's take the top 5 clusters.

```{r}
clusters <- cutree(gene_hclust, k = 5)

clusters <- clusters%>%
  enframe() %>% 
  rename(gene = name, cluster = value)
```

Here are the number of genes in each cluster. There are none with very few genes.

```{r}
table(clusters$cluster)
```

```{r}
# add cluster to main data
gc_expressed_trans_clusters <- gc_expressed_trans_long%>%
  left_join(., clusters)
```

With the DEGs, the patterns are similar to the full dataset, though perhaps more pronounced. The genes that were not assigned to a cluster (NA) are genes that are not strongly differentially expressed.

```{r}
ggplot(gc_expressed_trans_clusters%>%
         ungroup(), 
       aes(x = grp, y = z_score)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_point(aes(color = z_score), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  # geom_line(aes(group = gene), alpha = 0.1) +
  geom_line(stat = "summary",
            fun = "median", colour = "black", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```

Some of the trends might be easier to assess if we plot the expression profiles for individual genes. Let's sample 100 random genes from each cluster and plot them. 

```{r}
gene100_perclust <- gc_expressed_trans_clusters%>%
  ungroup()%>%
  mutate(cluster = as.factor(cluster))%>%
  select(gene, cluster)%>%
  distinct()%>%
  group_by(cluster)%>%
  slice_sample(n=100)%>%.$gene

ggplot(gc_expressed_trans_clusters%>%
         ungroup()%>%
         filter(gene %in% gene100_perclust), 
       aes(x = grp, y = z_score)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_line(aes(group = gene), alpha = 0.1) +
  geom_line(stat = "summary",
            fun = "median", colour = "red", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```

This uncovers a little more nuance within the clusters, such that we can see why some were clusters were split (e.g. more variance at some stages than others). This plot also shows that expression trends are not entirely explained by host, because within hosts expression often changed from one life stage to the next. This suggests that gene expression patterns will be better captured by the full model. But before looking at the full model, let's consider the DEGs among functions.

## DEGs among functions

One model tested which genes were differentially expressed at particular functions, like invasion, growth, transmission, etc. Here are the number of genes where counts were high enough that `DESeq2` performed a LRT:

```{r}
length(gc_degs_func$Gene)
```

Here are the number of DEGs at different levels of significance. There are fewer DEGs among functions than among hosts.

```{r}
gc_degs_func%>%
  summarize(p0.01 = sum(padj < 0.01),
            p0.001 = sum(padj < 0.001),
            p0.0001 = sum(padj < 0.0001),
            p0.00001 = sum(padj < 0.00001),
            p0.000001 = sum(padj < 0.000001))
```

Let's only take the genes that had p-values less than 0.0001.

```{r}
degs_func <- filter(gc_degs_func, padj < 0.0001)%>%.$Gene
```

Here is the log-transformed elbow plot, based on kmeans clustering, with those genes. There is maybe only 1 or 2 clusters.

```{r}
# function to compute total within-cluster sum of square 
wss <- function(k) {
  kmeans(
    gc_expressed_trans[row.names(gc_expressed_trans) %in% degs_func,],
    k, nstart = 10 )$tot.withinss
}

# Compute and plot wss for k = 1 to k = 15
k.values <- 1:15

# extract wss for 2-15 clusters
wss_values <- map_dbl(k.values, wss)

qplot(k.values, wss_values) +
  geom_line() + 
  labs(x = "Number of clusters K", y = "Total within-clusters sum of squares") +
  scale_x_log10()
```

Now, we filter the count matrix to just the DEGs and we re-calculate the distance matrix, which is then fed into the clustering algorithm (`method = 'ward.D2'`). 

```{r}
gene_dist <- dist(
  # distance matrix for just DEGs
  gc_expressed_trans[
    row.names(gc_expressed_trans) %in% degs_func,
    ]
  )

gene_hclust <- hclust(gene_dist, method = "ward.D2")
```

For comparison to the host model, we take the top 5 clusters.

```{r}
clusters <- cutree(gene_hclust, k = 5)

clusters <- clusters%>%
  enframe() %>% 
  rename(gene = name, cluster = value)
```

Here are the number of genes in each cluster. Some clusters are relatively small.

```{r}
table(clusters$cluster)
```

```{r}
# add cluster to main data
gc_expressed_trans_clusters <- gc_expressed_trans_long%>%
  left_join(., clusters)
```

The expression profiles shows that the first two clusters (which were the largest) are for genes up or down regulated in the reproductive stage.

```{r}
gene100_perclust <- gc_expressed_trans_clusters%>%
  ungroup()%>%
  mutate(cluster = as.factor(cluster))%>%
  select(gene, cluster)%>%
  distinct()%>%
  group_by(cluster)%>%
  slice_sample(n=100)%>%.$gene

ggplot(gc_expressed_trans_clusters%>%
         ungroup()%>%
         filter(gene %in% gene100_perclust), 
       aes(x = grp, y = z_score)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_line(aes(group = gene), alpha = 0.1) +
  geom_line(stat = "summary",
            fun = "median", colour = "red", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```

The expression profiles clearly suggest that expression does not depend entirely on the hosts or the function. Rather, they can depend on both.

## DEGs among all life stages

Thus, the model with all developmental stages is probably the best. Let's assess this by looking at the number of genes considered differentially expressed by different models.

```{r}
# table of which model comps identified which genes as significant
gc_degs_wide <- gc_degs%>%
  mutate(DEG = if_else(padj < 0.001, "yes", "no"))%>%
  select(-padj)%>%
  pivot_wider(names_from = Model, values_from = DEG)

# table of pvalues from all model comps
gc_degs_wide2 <- gc_degs%>%
  pivot_wider(names_from = Model, values_from = padj, names_prefix = "pval_")
gc_degs_wide <- gc_degs_wide%>%
  left_join(., gc_degs_wide2)
rm(gc_degs_wide2)
```

### DEGs, host vs developmental stage

This table shows the number of genes identified as differentially expressed (p < 0.001) among 'hosts' and among 'developmental stages'. A large number of genes (~7000) were considered DE by both models. But the full model considered another ~4000 genes as DE that the host model did not. By contrast, only a small number of genes (75) were considered DE by the host model but not the full model. It is also reassuring that the ~1000 genes with high enough counts to justify a LRT in the full model, but not in the host model, were all not significant.

```{r}
with(gc_degs_wide, addmargins(table(int_condition, int_host, useNA = "ifany"), margin = c(1,2)))
```

Of the ~7000 genes that were DE in both models, the p-value was almost always lower in the full model, suggesting that most of these genes do not vary in a purely host-driven way.

```{r}
with(gc_degs_wide%>%filter(pval_int_host < 0.001),
     (table(pval_int_condition < pval_int_host, useNA = "ifany")))
```

The p-values are from model comparisons with an intercept-only model (i.e. host vs int-only, full vs int-only). Thus, the p-value are just a test of total variance explained by the model. A better comparison is how much more variance is explained in the full vs the host-only model. Let's consider that comparison. 

The table rows tally the genes considered DE by the full model (int_condition) whereas the columns are the genes where the full model is an improvement over the host-only model (host_condition). Out of all DE genes (~11000), most (9000) are not purely host-driven, i.e. the full model is an improvement over the host-only model. 

```{r}
with(gc_degs_wide, addmargins(table(int_condition, host_condition, useNA = "ifany"), margin = c(1,2)))
```

Still, there are about 2000 DE genes for which the full model was not an improvement. Let's look at the profiles for these genes.

```{r}
degs_host_pure <- gc_degs_wide%>%
  filter(int_condition == "yes", host_condition == "no")%>%
  .$Gene
```

The log-transformed elbow plot suggests there are only a couple clusters.

```{r}
# function to compute total within-cluster sum of square 
wss <- function(k) {
  kmeans(
    gc_expressed_trans[row.names(gc_expressed_trans) %in% degs_host_pure,],
    k, nstart = 10 )$tot.withinss
}

# Compute and plot wss for k = 1 to k = 15
k.values <- 1:15

# extract wss for 2-15 clusters
wss_values <- map_dbl(k.values, wss)

qplot(k.values, wss_values) +
  geom_line() + 
  labs(x = "Number of clusters K", y = "Total within-clusters sum of squares") +
  scale_x_log10()
```

Unsurprisingly, these are the genes that are mainly up or down regulated at the end of the life cycle in the in vitro bird.

```{r}
gene_dist <- dist(
  # distance matrix for just DEGs
  gc_expressed_trans[
    row.names(gc_expressed_trans) %in% degs_host_pure,
    ]
  )

gene_hclust <- hclust(gene_dist, method = "ward.D2")

clusters <- cutree(gene_hclust, k = 5)

clusters <- clusters%>%
  enframe() %>% 
  rename(gene = name, cluster = value)

# table(clusters$cluster)

# add cluster to main data
gc_expressed_trans_clusters <- gc_expressed_trans_long%>%
  left_join(., clusters)

gene100_perclust <- gc_expressed_trans_clusters%>%
  ungroup()%>%
  mutate(cluster = as.factor(cluster))%>%
  select(gene, cluster)%>%
  distinct()%>%
  group_by(cluster)%>%
  slice_sample(n=100)%>%.$gene

ggplot(gc_expressed_trans_clusters%>%
         ungroup()%>%
         filter(gene %in% gene100_perclust), 
       aes(x = grp, y = z_score)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_line(aes(group = gene), alpha = 0.1) +
  geom_line(stat = "summary",
            fun = "median", colour = "red", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```


### DEGs, function vs devo stage

Now, we compare the genes identified as differentially expressed (p < 0.001) among 'functional stages' and among 'developmental stages'. Like the host model comps above, large number of genes (~6000) were considered DE by both models. The full model considered another ~5500 genes as DE that the stage model did not, which was more than in the host model. By contrast, few genes (81) were considered DE by the stage model but not the full model. Again, the genes with high enough counts to justify a LRT in the full model (~750), but not in the simpler stage model, were all not significant.

```{r}
with(gc_degs_wide, addmargins(table(int_condition, int_stage, useNA = "ifany"), margin = c(1,2)))
```

For almost all of the genes that were DE in both models, the p-value was lower in the full model, suggesting that most of these genes do not vary in a purely function-driven way.

```{r}
with(gc_degs_wide%>%filter(pval_int_stage < 0.001),
     (table(pval_int_condition < pval_int_stage, useNA = "ifany")))
```

We also directly compared the stage-only and full models and found patterns similar to the host-only vs full comparison. The table below tallies the genes considered DE by the full model (int_condition) vs those genes where the full model is an improvement over the function-only model (stage_condition). Most DE genes (~9000 out of 11000) are not purely function-driven, i.e. the full model was an improvement. 

```{r}
with(gc_degs_wide, addmargins(table(int_condition, stage_condition, useNA = "ifany"), margin = c(1,2)))
```

But as above, there are about 2000 DE genes for which the full model was not an improvement. These are probably genes upregulated in "reproducing" stages.

```{r}
degs_func_pure <- gc_degs_wide%>%
  filter(int_condition == "yes", stage_condition == "no")%>%
  .$Gene
```

The expression profiles are consistent with that.

```{r}
gene_dist <- dist(
  # distance matrix for just DEGs
  gc_expressed_trans[
    row.names(gc_expressed_trans) %in% degs_func_pure,
    ]
  )

gene_hclust <- hclust(gene_dist, method = "ward.D2")

clusters <- cutree(gene_hclust, k = 5)

clusters <- clusters%>%
  enframe() %>% 
  rename(gene = name, cluster = value)

# table(clusters$cluster)

# add cluster to main data
gc_expressed_trans_clusters <- gc_expressed_trans_long%>%
  left_join(., clusters)

gene100_perclust <- gc_expressed_trans_clusters%>%
  ungroup()%>%
  mutate(cluster = as.factor(cluster))%>%
  select(gene, cluster)%>%
  distinct()%>%
  group_by(cluster)%>%
  slice_sample(n=100)%>%.$gene

ggplot(gc_expressed_trans_clusters%>%
         ungroup()%>%
         filter(gene %in% gene100_perclust), 
       aes(x = grp, y = z_score)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_line(aes(group = gene), alpha = 0.1) +
  geom_line(stat = "summary",
            fun = "median", colour = "red", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```

### All DEGs expression profiles

Here are the number of genes where counts were high enough that `DESeq2` performed a LRT:

```{r}
length(gc_degs_all$Gene)
```

Out of these, this number had low expression levels under our criteria above.

```{r}
sum(gc_degs_all$Gene %in% low_genes)
```

Moreover, they are the genes that are not differentially expressed: 

```{r}
ggplot(gc_degs_all, aes(x = padj+0.00000001)) +
  geom_density(aes(color = Gene %in% low_genes)) +
  labs(color = "Low expression") +
  scale_x_log10()
```

So, when we take a conservative p-value threshold, many of these genes will be removed. Here are the number of DEGs at different levels of significance. This is higher than the host-only or stage-only model. A 10-fold change in the p-value usually removes roughly 1000 genes from the list.

```{r}
gc_degs_all%>%
  summarize(p0.01 = sum(padj < 0.01),
            p0.001 = sum(padj < 0.001),
            p0.0001 = sum(padj < 0.0001),
            p0.00001 = sum(padj < 0.00001),
            p0.000001 = sum(padj < 0.000001))
```

```{r}
# # number of genes at different cutoffs
# gc_degs_all%>%
#   arrange(desc(padj))%>%
#   mutate(cum_dist = cume_dist(padj),
#          genes = row_number())%>%
#   ggplot(., aes(genes, padj)) +
#   geom_line() +
#   # scale_x_log10() +
#   scale_y_log10(limits = c(0.00000000000000000001, 1))
```

Let's only take the genes that had p-values less than 0.0001.

```{r}
degs_all <- filter(gc_degs_all, padj < 0.0001)%>%.$Gene
```

Here is an log-transformed elbow plot, based on kmeans clustering, with those genes. There are at least 4 clusters.

```{r}
# function to compute total within-cluster sum of square 
wss <- function(k) {
  kmeans(
    gc_expressed_trans[row.names(gc_expressed_trans) %in% degs_all,],
    k, nstart = 10 )$tot.withinss
}

# Compute and plot wss for k = 1 to k = 20
k.values <- 1:15

# extract wss for 2-15 clusters
wss_values <- map_dbl(k.values, wss)

qplot(k.values, wss_values) +
  geom_line() + 
  labs(x = "Number of clusters K", y = "Total within-clusters sum of squares") +
  scale_x_log10()
```

Now, we filter the count matrix to just the DEGs and we re-calculate the distance matrix, which is then fed into the clustering algorithm (`method = 'complete'`). 

```{r}
gene_dist <- dist(
  # distance matrix for just DEGs
  gc_expressed_trans[
    row.names(gc_expressed_trans) %in% degs_all,
    ]
  )

gene_hclust <- hclust(gene_dist, method = "ward.D2")
```

Given the elbow plot, let's take the top 8 clusters.

```{r}
clusters <- cutree(gene_hclust, k = 8)

clusters <- clusters%>%
  enframe() %>% 
  rename(gene = name, cluster = value)
```

Here are the number of genes in each cluster. There are none with very few genes.

```{r}
table(clusters$cluster)
```

```{r}
# add cluster to main data
gc_expressed_trans_clusters <- gc_expressed_trans_long%>%
  left_join(., clusters)
```

With the DEGs, the patterns are clearer, but some of the clusters still look somewhat redundant. The genes that were not assigned to a cluster (NA) are genes that are not strongly differentially expressed.

```{r}
ggplot(gc_expressed_trans_clusters%>%
         ungroup(), 
       aes(x = grp, y = z_score)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_point(aes(color = z_score), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  # geom_line(aes(group = gene), alpha = 0.1) +
  geom_line(stat = "summary",
            fun = "median", colour = "black", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```

Some of the trends might be easier to assess if we plot the expression profiles for individual genes. Let's sample 100 random genes from each cluster and plot them. This uncovers a little more nuance within the clusters, such that we can see why some clusters were split (e.g. more variance at some stages than others).

```{r}
gene100_perclust <- gc_expressed_trans_clusters%>%
  ungroup()%>%
  mutate(cluster = as.factor(cluster))%>%
  select(gene, cluster)%>%
  distinct()%>%
  group_by(cluster)%>%
  slice_sample(n=100)%>%.$gene

ggplot(gc_expressed_trans_clusters%>%
         ungroup()%>%
         filter(gene %in% gene100_perclust), 
       aes(x = grp, y = z_score)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_line(aes(group = gene), alpha = 0.1) +
  geom_line(stat = "summary",
            fun = "median", colour = "red", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```

New patterns do not obviously emerge when the number of clusters is expanded.

```{r}
clusters <- cutree(gene_hclust, k = 15)

clusters <- clusters%>%
  enframe() %>% 
  rename(gene = name, cluster = value)

# add cluster to main data
gc_expressed_trans_clusters <- gc_expressed_trans_long%>%
  left_join(., clusters)

gene100_perclust <- gc_expressed_trans_clusters%>%
  ungroup()%>%
  mutate(cluster = as.factor(cluster))%>%
  select(gene, cluster)%>%
  distinct()%>%
  group_by(cluster)%>%
  slice_sample(n=30)%>%.$gene

ggplot(gc_expressed_trans_clusters%>%
         ungroup()%>%
         filter(gene %in% gene100_perclust), 
       aes(x = grp, y = z_score)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_line(aes(group = gene), alpha = 0.3) +
  geom_line(stat = "summary",
            fun = "median", colour = "red", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```

## Heatmap

Some of the clusters in the previous plot are rather similar. A common way to visualize clusters, such that similar ones are next to each other, are heatmaps. I used this [approach](https://genviz.org/module-04-expression/0004/02/01/DifferentialExpression/) to build a heatmap.

```{r}
library(ggdendro)
library(gtable)
library(grid)
library(gridExtra)
```

I picked the 7000 genes that were most strongly differentially expressed across life stages. Then, I reran the clustering algorithm and produced a dendrogram.

```{r}
# pick most DE genes
degs_top1000 <- gc_degs_all%>%
  arrange(padj)%>%
  slice_head(n = 7000)%>%
  .$Gene

# rerun clustering algorithm
gene_dist <- dist(
  # distance matrix for just DEGs
  gc_expressed_trans[
    row.names(gc_expressed_trans) %in% degs_top1000,
    ]
  )

gene_hclust <- hclust(gene_dist, method = "ward.D2")

# extract order of genes in cluster
gene_order <- row.names(
  gc_expressed_trans[
    row.names(gc_expressed_trans) %in% degs_top1000,
    ][gene_hclust$order,]
  )

# create dendrogram from clustering output
dendro <- as.dendrogram(gene_hclust)
dendro_data <- segment(dendro_data(dendro, type = "rectangle"))
dendrogram <- ggplot(dendro_data) + 
  geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) + 
  scale_x_continuous(expand=c(0, 0)) + scale_y_reverse() +
  coord_flip() + 
  theme(panel.border = element_blank()) +
  theme_dendro() 
# dendrogram
```

The normalized expression data for these genes need to be rearranged into long format for plotting.

```{r}
# rearrange data for plotting
gc_expressed_trans_long_hm <- as.data.frame(
  gc_expressed_trans[
    row.names(gc_expressed_trans) %in% degs_top1000,
    ]
  )
gc_expressed_trans_long_hm$gene <- row.names(gc_expressed_trans_long_hm)

gc_expressed_trans_long_hm <- gc_expressed_trans_long_hm%>%
  pivot_longer(cols = starts_with("Condition"), names_to = "sample", values_to = "trans_counts")%>%
  mutate(grp = gsub(pattern = "[:0-9:]", "", x = sample))

gc_expressed_trans_long_hm <- gc_expressed_trans_long_hm%>%
  left_join(., 
            md%>%select(Unique_name, func=Stage, host=Host),
            by = c("sample" = "Unique_name")
            )

gc_expressed_trans_long_hm <- gc_expressed_trans_long_hm%>%
   mutate(gene = factor(gene, levels = gene_order))

dx <- data.frame(grp = unique(gc_expressed_trans_long_hm$grp),
                    label = x_ax_lab)

gc_expressed_trans_long_hm <- left_join(gc_expressed_trans_long_hm, dx)
```

The final plot is a conglomeration of several sub-elements, including the dendrogram, a heatmap, and tiles that distinguish the groups.

```{r}
# make heatmap
heatmap <- ggplot(gc_expressed_trans_long_hm, aes(x = sample, y = gene)) +
  geom_tile(aes(fill = trans_counts)) +
  scale_fill_distiller(type = "div", palette = "RdBu") +
  theme(axis.text = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.y = element_blank(),
        panel.grid = element_blank()) +
  labs(fill = "z-score")
# heatmap
```

```{r}
# make dataset for tiles above heatmap
dat_bars_above_heatmap <- gc_expressed_trans_long_hm%>%
         select(sample, label)%>%
         distinct()%>%
         mutate(label = fct_relevel(label, x_ax_lab))
dat_bars_above_heatmap2 <- dat_bars_above_heatmap%>%
  mutate(rank = rank(sample))%>%
  group_by(label)%>%
  summarise(rank = median(rank))
```

```{r}
sample_map <- ggplot(gc_expressed_trans_long_hm%>%
         select(sample, label)%>%
         distinct()%>%
         mutate(label = fct_relevel(label, x_ax_lab)), 
       aes(x=sample, y=1, fill=label)) + 
  geom_tile() + 
  geom_text(data = dat_bars_above_heatmap2,
            aes(x = rank, y = 1, label = label),
            angle = 90) +
  scale_x_discrete(expand=c(0, 0)) + 
  scale_y_discrete(expand=c(0, 0)) + 
  scale_fill_manual(name="Tissue", 
                    values=rep(c("white","gray"), 5)) + 
  guides(fill = F) +
  theme_void()
  
# sample map
```

After making the sub-elements, they need to be aligned and glued together. For this they are converted to 'grobs'.

```{r}
################################################################################
################# Step 3: convert to everything to grobs #######################

# note! before this step as mentioned you might need to alter the expand parameters in the plot scales for all the plots we do that here

# convert the heatmap to a grob
heatmapGrob <- ggplotGrob(heatmap + scale_x_discrete(expand=c(0, 0)) + scale_y_discrete(expand=c(0, 0)))

# convert the dendrogram to a grob
# note! we flipped the axis above so the x-axis is now displayed as what we would think of as the y-axis
geneDendrogramGrob <- ggplotGrob(dendrogram + scale_x_discrete(expand=c(0, 0)))
sampleClinicalGrob <- ggplotGrob(sample_map)
```



```{r}
################################################################################
######### Step 4: align the gene dendrograms to match the heatmap ##############

# check that the both the heatmap and gene dendrogram have the same number of vertical elements
#length(heatmapGrob$heights) == length(geneDendrogramGrob$heights)

# make sure every height between the two grobs is the same
maxHeight <- unit.pmax(geneDendrogramGrob$heights, heatmapGrob$heights)
geneDendrogramGrob$heights <- as.list(maxHeight)
heatmapGrob$heights <- as.list(maxHeight)
```

```{r}
################################################################################
# Step 4b: we have a new heatmap so we need to re-align the horizontal elements #

# repeat the steps in the tutorial

# check the widths of each grob
#heatmapGrob$widths
#sampleClinicalGrob$widths

# add in the missing columns
sampleClinicalGrob <- gtable_add_cols(sampleClinicalGrob, heatmapGrob$widths[7], 6)
sampleClinicalGrob <- gtable_add_cols(sampleClinicalGrob, heatmapGrob$widths[8], 7)

# make sure every width between all grobs is the same
maxWidth <- unit.pmax(sampleClinicalGrob$widths, heatmapGrob$widths)
sampleClinicalGrob$widths <- as.list(maxWidth)
heatmapGrob$widths <- as.list(maxWidth)
sampleClinicalGrob$widths <- as.list(maxWidth)
```

Here is the final product, showing the major clusters.

```{r}
################################################################################
############### Step 5: create a blank panel ###################################

# we can use grid graphics for this
grid.newpage()
blankPanel <- grid.rect(gp=gpar(col="white"))

################################################################################
############### Step 6: Arrange the final result ###############################

# arrange all the plots together
finalGrob_v2 <- arrangeGrob(blankPanel, sampleClinicalGrob, geneDendrogramGrob, heatmapGrob, ncol=2, nrow=2, widths=c(1,5), heights=c(1,6))

# draw the final result
grid.draw(finalGrob_v2)
```


# *Clust* algorithm

Alternatively, different clustering algorithms could be used. For example, instead of assigning all genes to clusters, this [algorithm](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-018-1536-8) tries to extract clusters of genes with similar expression. I ran the algorithm (see commands [here](run_clust.txt)) on the full set of genes and the differentially expressed genes.

```{r}
# write files for clust - all genes
gc_for_clust <- gc%>%
  mutate(gene_id = gsub(pattern = "gene:", "", gene))%>%
  select(gene_id, ConditionA01:ConditionL10)
write_tsv(gc_for_clust, file = "clust_input/Schisto_gene_matrix.tsv")

replicates_file_for_clust <- gc_long%>%
  group_by(grp)%>%
  summarise(sample_names = paste0(unique(sample), collapse = ", "))

replicates_file_for_clust <- replicates_file_for_clust%>%
  ungroup()%>%
  mutate(data_name = "Schisto_gene_matrix.tsv")%>%
  select(data_name, grp, sample_names)
write_tsv(replicates_file_for_clust, file = "clust_input/replicates_file.tsv",
          col_names = FALSE)
```
```{r}
# write files for clust - just DEGs
gc_for_clust <- gc%>%
  filter(gene %in% degs)%>%
  mutate(gene_id = gsub(pattern = "gene:", "", gene))%>%
  select(gene_id, ConditionA01:ConditionL10)
write_tsv(gc_for_clust, file = "clust_input/Schisto_gene_matrix_onlyDEGs.tsv")

replicates_file_for_clust2 <- replicates_file_for_clust%>%
  mutate(data_name = "Schisto_gene_matrix_onlyDEGs.tsv")
write_tsv(replicates_file_for_clust2, file = "clust_input/replicates_file2.tsv",
          col_names = FALSE)
```

## All genes

*clust* only extracted two clusters from the full dataset.

```{r}
# read in cluster data
clust_out_allgenes <- read_tsv(file = "clust_output/all_expressed/Clusters_Objects.tsv")
```
```{r}
clust_out_allgenes <- clust_out_allgenes%>%
  pivot_longer(., cols = everything(), names_to = "cluster", values_to = "gene")%>%
  filter(gene != "Genes")
# n_distinct(clust_out_allgenes$cluster)
```
```{r}
gc_expressed_trans_long2 <- gc_expressed_trans_long%>%
  ungroup()%>%
  mutate(gene = gsub(pattern = "gene:", "", gene))

# add cluster to main data
gc_expressed_trans_clusters2 <- gc_expressed_trans_long2%>%
  left_join(., clust_out_allgenes)
```
When we plot them, we see that one cluster groups genes that are down regulated in the early life stages, whereas the other cluster is quite variable.

```{r}
ggplot(gc_expressed_trans_clusters2%>%
         filter(!is.na(cluster)), 
       aes(x = grp, y = z_score)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_line(aes(group = gene), alpha = 0.05) +
  geom_line(stat = "summary",
            fun = "median", colour = "red", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```

## Differentially expressed genes

*clust* only extracted one cluster from the set of DEGs.

```{r}
# read in cluster data
clust_out_degs <- read_tsv(file = "clust_output/only_DEGs/Clusters_Objects.tsv")
```

```{r}
clust_out_degs <- clust_out_degs%>%
  pivot_longer(., cols = everything(), names_to = "cluster", values_to = "gene")%>%
  filter(gene != "Genes")
n_distinct(clust_out_degs$cluster)
```
```{r}
# add cluster to main data
gc_expressed_trans_clusters2 <- gc_expressed_trans_long2%>%
  left_join(., clust_out_degs)
```

The plot of this single cluster is not very convincing. 

```{r}
ggplot(gc_expressed_trans_clusters2%>%
         filter(!is.na(cluster)), 
       aes(x = grp, y = z_score)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_line(aes(group = gene), alpha = 0.05) +
  geom_line(stat = "summary",
            fun = "median", colour = "red", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```

# Summary

In conclusion, some of the largest changes in gene expression occur at the beginning and end of the life cycle. Most changes in gene expression cannot be neatly attributed to changing the host or changing the function. Rather, gene expression can vary within hosts and among functionally similar stages in different hosts.