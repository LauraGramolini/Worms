---
title: "Clustering of genes by expression profiles"
output: 
  github_document:
    toc: true
    df_print: kable
---

This script will cluster genes that have similar patterns of expression.

```{r setup, include=FALSE}
library(tidyverse)
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)
options(stringsAsFactors = FALSE)
theme_set(theme_bw())
theme_update(panel.grid.minor = element_blank())
```

First, we load the gene count table for *Schistocephalus solidus*.

```{r}
gc <- read.table(file = "../data/SScountdf.csv", header = T, sep = " ") # gene count
md <- read.delim(file = "../data/schistoData.txt", header = T) # metadata
md <- select(md, -X)
```

There are ~20,000 genes from 72 samples.

```{r}
dim(gc)
```

```{r}
# add gene name to data
gc$gene <- row.names(gc)
```

The data are in wide format with each column representing a sample and each row a gene. We will make the data long, so that each combination of gene and sample has its own row (i.e. all expression counts are in a single column).

```{r}
gc_long <- gc%>%
  pivot_longer(cols = starts_with("Condition"), names_to = "sample", values_to = "counts")

gc_long <- gc_long%>%
  mutate(grp = gsub(pattern = "[:0-9:]", "", x = gc_long$sample))
```

Here is the distribution of counts for every gene in every sample. In most samples in most genes, no expression is detectable. 

```{r}
ggplot(gc_long, aes(x = counts+.1)) +
  geom_histogram(bins = 60) +
  scale_x_log10()
```

When we exclude the zeros (no expression), we see a bimodal distribution. In many genes in many samples, counts are low (peak at one) and probably just represent noise. The peak at higher values probably represents "real" expression, say greater than 10 counts per gene.

```{r}
ggplot(gc_long%>%filter(counts>0), aes(x = counts)) +
  geom_histogram(bins = 60) +
  scale_x_log10(breaks = c(1, 10, 100, 1000, 10000))
```
The pattern is similar within each of our treatment groups. There is a fair amount of low-level expression that is probably just noise, and then from 10 counts or so there seems to be genuine expression. The separate lines are for the different samples. They show that the distribution of expression counts is similar across replicates.

```{r}
ggplot(gc_long, aes(x = counts)) +
  geom_density(aes(group = sample), 
               color = "gray", fill = "pink", alpha = 0.1) +
  scale_x_log10(breaks = c(1, 10, 100, 1000)) +
  facet_wrap(~grp)
```

We can take the median expression level for each gene in each condition and make the same plot. Clearly some of the low-level expression can be removed.

```{r}
gc_avg_by_condition <- gc_long%>%
  group_by(grp, gene)%>%
  summarise(median = median(counts),
            min = min(counts))
```
```{r}
ggplot(gc_avg_by_condition, aes(x = median)) +
  geom_density(color = "gray", fill = "pink", alpha = 0.1) +
  scale_x_log10(breaks = c(1, 10, 100, 1000)) +
  facet_wrap(~grp)
```
```{r}
# for each gene take the maximum median expression level for any given condition
gc_max_exp_in_at_least_cond <- gc_avg_by_condition%>%
  group_by(gene)%>%
  summarise(max_med_count = max(median))

# ggplot(gc_max_exp_in_at_least_cond, aes(x = max_med_count)) +
#   geom_density(color = "gray", fill = "pink", alpha = 0.1) +
#   scale_x_log10(breaks = c(1, 10, 100, 1000))
```

As an arbitrary threshold, we will remove genes that do not have a median expression level of at least 10 counts in at least one condition.

```{r}
low_genes <- gc_max_exp_in_at_least_cond%>%
  filter(max_med_count < 10)%>%.$gene
```

Here is the percent of genes removed.

```{r}
round(length(low_genes)/length(gc$gene), 3)
```

Doubling the threshold for expression counts (20) only removes a few percent more.

```{r}
low_genes20 <- gc_max_exp_in_at_least_cond%>%
  filter(max_med_count < 20)%>%.$gene
round(length(low_genes20)/length(gc$gene), 3)
```

Similarly halving the threshold (5) would only add a few percent of the genes back into the analysis.

```{r}
low_genes5 <- gc_max_exp_in_at_least_cond%>%
  filter(max_med_count < 5)%>%.$gene
round(length(low_genes5)/length(gc$gene), 3)
```

Specifically, it would add this many genes back into the analysis:

```{r}
length(low_genes)-length(low_genes5)
rm(low_genes20, low_genes5)
```

```{r}
# reduce gene count to expressed genes
gc_expressed <- gc%>%
  filter(!gene %in% low_genes)
```

Now that we have a list of expressed genes, we want to make them comparable. Specifically, expression counts are usually overdispersed, with the variance increasing with the mean. Therefore, for clustering, it is [recommended](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#data-transformations-and-visualization) to transform the data. The package `DESeq2` provides a function for this `vst`.

```{r}
gc_expressed_trans <- DESeq2::vst(
  gc_expressed%>%select(-gene)%>%as.matrix()
  )
```

The variance stabilizing transforms the data but it is kept on a log scale. That is, genes that are highly expressed should still have high values compared to lowly expressed genes. We can see this by plotting the gene-level relationship between mean expression before and after transformation. Looks similar to a log-transformation.

```{r}
mean_expr_untrans <- rowMeans(
  gc_expressed%>%select(-gene)%>%as.matrix()
)

mean_expr_trans <- rowMeans(gc_expressed_trans)

qplot(mean_expr_untrans, mean_expr_trans)
rm(mean_expr_untrans, mean_expr_trans)
```

We do not want to cluster genes together that have high vs low expression. Rather, we are more interested in the pattern of gene expression across the life cycle, i.e. genes that show similar patterns of increasing and decreasing expression. Therefore, we scale the transformed expression values to a z-score for each gene.

```{r}
gc_expressed_trans <- gc_expressed_trans%>% 
  # transpose the matrix so genes are as columns
  t() %>% 
  # apply scalling to each column of the matrix (genes)
  scale() %>% 
  # transpose back so genes are as rows again
  t()
```

```{r}
# put z-scores into long format
gc_expressed_trans_long <- as.data.frame(gc_expressed_trans)
gc_expressed_trans_long$gene <- row.names(gc_expressed_trans_long)
gc_expressed_trans_long <- gc_expressed_trans_long%>%
  pivot_longer(cols = starts_with("Condition"), names_to = "sample", values_to = "zscore")%>%
  mutate(grp = gsub(pattern = "[:0-9:]", "", x = sample))

gc_expressed_trans_long <- gc_expressed_trans_long%>%
  left_join(., 
            md%>%select(Unique_name, func=Stage, host=Host),
            by = c("sample" = "Unique_name")
            )
gc_expressed_trans_long <- gc_expressed_trans_long%>%
  group_by(gene, grp, func, host)%>%
  summarise(z_score = median(zscore))
```


For the transformed, scaled expression data, we calculate the euclidean distance between each gene.

```{r}
gene_dist <- dist(gc_expressed_trans)
```

This distance matrix is then fed to the hierarchical clustering algorithm. The clustering method is 'complete linkage' which aims to put genes into similar clusters.

```{r}
gene_hclust <- hclust(gene_dist, method = "complete")
```

```{r}
# # plot dendogram
# plot(gene_hclust, labels = FALSE)
# abline(h = 10, col = "brown", lwd = 2)
```

After running the clustering algorithm, we would like to visualize the clusters. Let's take the first 10 clusters.

```{r}
clusters <- cutree(gene_hclust, k = 10)

clusters <- clusters%>%
  enframe() %>% 
  rename(gene = name, cluster = value)
```

Here are the number of genes in each cluster:

```{r}
table(clusters$cluster)
```

We add the clusters to the transformed expression data for plotting.

```{r}
# add cluster to main data
gc_expressed_trans_clusters <- gc_expressed_trans_long%>%
  left_join(., clusters)
```

The time-course of the gene expression is then plotted.

```{r}
# x_ax_lab <- gc_expressed_trans_clusters%>%
#   ungroup()%>%
#   mutate(stage_name = paste0(substr(host, 1, 3), "-", substr(func, 1, 3)))%>%
#   select(stage_name)%>%
#   distinct()%>%.$stage_name
x_ax_lab <- c("free", "cop-inf", "cop-grow", "cop-trans", "fish-inf", "fish-grow", "fish-grow2"
, "fish-trans", "bird-inf", "bird-repr")
```

```{r}
ggplot(gc_expressed_trans_clusters%>%
         ungroup(), 
       aes(x = grp, y = z_score)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_point(aes(color = z_score), alpha = 0.1) +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_point(aes(color = z_score), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  # geom_line(aes(group = gene), alpha = 0.1) +
  geom_line(stat = "summary",
            fun = "median", colour = "black", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```

Ten clusters was arbitrary. One way to estimate how many clusters there are in the data is to perform a faster clustering algorithm (kmeans) with different numbers of pre-defined clusters. Then, we can see how the variance within clusters decreases as a function of the number of clusters. Here is the pattern:

```{r}
# function to compute total within-cluster sum of square 
wss <- function(k) {
  kmeans(gc_expressed_trans, k, nstart = 10 )$tot.withinss
}

# Compute and plot wss for k = 1 to k = 15
k.values <- 1:25

# extract wss for 2-15 clusters
wss_values <- map_dbl(k.values, wss)

qplot(k.values, wss_values) +
  geom_line() + 
  labs(x = "Number of clusters K", y = "Total within-clusters sum of squares") 
```

In this "elbow plot", we are looking for a break in the line (an elbow) where additional clusters do not reduce withing cluster variance much. Unfortunately, the trend looks fairly linear on a log-scale, which we can plot. Perhaps ther is a break at 4 and 7 clusters. 

```{r}
qplot(k.values, wss_values) +
  geom_line() + 
  labs(x = "Number of clusters K", y = "Total within-clusters sum of squares") +
  scale_x_log10()
```

Thus, let's go back to our hierarchical clustering, but now take the top 7 clusters. Here are the patterns. Some patterns pop out, like cluster 7 being upregulated in copepods. But overall, I think the clustering algorithm could do better.

```{r}
clusters <- cutree(gene_hclust, k = 7)

clusters <- clusters%>%
  enframe() %>% 
  rename(gene = name, cluster = value)
```

Here are the number of genes in each cluster:

```{r}
table(clusters$cluster)
```


```{r}
# add cluster to main data
gc_expressed_trans_clusters <- gc_expressed_trans_long%>%
  left_join(., clusters)
```

```{r}
ggplot(gc_expressed_trans_clusters%>%
         ungroup(), 
       aes(x = grp, y = z_score)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_point(aes(color = z_score), alpha = 0.1) +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_point(aes(color = z_score), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  # geom_line(aes(group = gene), alpha = 0.1) +
  geom_line(stat = "summary",
            fun = "median", colour = "black", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```

Let's try a different clustering algorithm. Clusters can vary quite a lot between clustering algorithms (see [here](https://cran.r-project.org/web/packages/dendextend/vignettes/Cluster_Analysis.html)). Instead of 'complete linkage', we'll try 'average', which makes a UPGMA tree from the distance matrix.


```{r}
gene_hclust <- hclust(gene_dist, method = "average")
# # plot dendogram
# plot(gene_hclust, labels = FALSE)

clusters <- cutree(gene_hclust, k = 7)

clusters <- clusters%>%
  enframe() %>% 
  rename(gene = name, cluster = value)
```

Here are the number of genes in each cluster - they are quite different:

```{r}
table(clusters$cluster)
```

```{r}
# add cluster to main data
gc_expressed_trans_clusters <- gc_expressed_trans_long%>%
  left_join(., clusters)
```

There is still a lack of clear patterns.

```{r}
ggplot(gc_expressed_trans_clusters%>%
         ungroup(), 
       aes(x = grp, y = z_score)) +
  # background for copepod stage
  annotate("rect",
           xmin=1.5, xmax=4.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_point(aes(color = z_score), alpha = 0.1) +
  # background for bird stages
  annotate("rect",
           xmin=8.5, xmax=10.5, ymin = -Inf, ymax = Inf,
           fill = "gray") +
  geom_point(aes(color = z_score), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  # geom_line(aes(group = gene), alpha = 0.1) +
  geom_line(stat = "summary",
            fun = "median", colour = "black", size = 1, 
            aes(group = 1)) +
  scale_x_discrete(labels = x_ax_lab, 
                   guide = guide_axis(angle = 90)) +
  scale_color_distiller(type = "div", palette = "RdBu") +
  facet_wrap(~ as.factor(cluster)) +
  theme(panel.grid.major = element_blank(),
        axis.title.x = element_blank()
        )
```

One way to improve the clustering would be to repeat clustering using only differentially expressed genes. Alternatively, different clustering algorithms could be used. For example, instead of assigning all genes to clusters, this  [algorithm](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-018-1536-8) tries to extract clusters of genes.

